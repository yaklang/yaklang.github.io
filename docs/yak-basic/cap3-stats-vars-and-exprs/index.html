<!doctype html>
<html class="docs-version-current" lang="zh-CN" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Yak Program Language Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Yak Program Language Blog Atom Feed">
<link rel="search" type="application/opensearchdescription+xml" title="Yak Program Language" href="/opensearch.xml"><title data-react-helmet="true">Yak 语言中的语句、变量和表达式 | Yak Program Language</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://yaklang.com/docs/yak-basic/cap3-stats-vars-and-exprs"><meta data-react-helmet="true" name="docsearch:language" content="zh-CN"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Yak 语言中的语句、变量和表达式 | Yak Program Language"><meta data-react-helmet="true" name="description" content="从本章节开始，笔者将带领大家正式开始Yak语言的学习。本章内容包含Yak语言中语句的类型、变量的定义与使用、基本数据类型的定义与使用，复合类型以及Yak语言中出现的运算符和表达式。"><meta data-react-helmet="true" property="og:description" content="从本章节开始，笔者将带领大家正式开始Yak语言的学习。本章内容包含Yak语言中语句的类型、变量的定义与使用、基本数据类型的定义与使用，复合类型以及Yak语言中出现的运算符和表达式。"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://yaklang.com/docs/yak-basic/cap3-stats-vars-and-exprs"><link data-react-helmet="true" rel="alternate" href="https://yaklang.com/docs/yak-basic/cap3-stats-vars-and-exprs" hreflang="zh-CN"><link data-react-helmet="true" rel="alternate" href="https://yaklang.com/en/docs/yak-basic/cap3-stats-vars-and-exprs" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://yaklang.com/docs/yak-basic/cap3-stats-vars-and-exprs" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.fa6250db.css">
<link rel="preload" href="/assets/js/runtime~main.1717b6bd.js" as="script">
<link rel="preload" href="/assets/js/main.b0c9a813.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="My Site Logo" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/img/logo.png" alt="My Site Logo" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"><b class="navbar__title"></b></a><a class="navbar__item navbar__link diy-link-item" href="/docs/intro">Yak 语言文档</a><a class="navbar__item navbar__link diy-link-item" href="/api-manual/intro">API 手册</a><a class="navbar__item navbar__link diy-link-item" href="/products/intro">Yakit 使用手册</a><a class="navbar__item navbar__link diy-link-item" href="/articles/intro">技术博客</a><a class="navbar__item navbar__link diy-link-item" href="/irify">静态代码分析技术</a><a class="navbar__item navbar__link diy-link-item" href="/Yaklab/yaklab">YakLab 实战手册</a><div class="navbar__item dropdown dropdown--hoverable"><a class="navbar__link diy-link-item">关于我们</a><ul class="dropdown__menu"><li><a activeclassname="dropdown__link--active" href="/team" to="/team" class="dropdown__link diy-link-item" target="_blank">关于我们</a></li><li><a activeclassname="dropdown__link--active" href="/cooperativePartner" to="/cooperativePartner" class="dropdown__link diy-link-item" target="_blank">合作伙伴</a></li></ul></div></div><div class="navbar__items navbar__items--right"><a href="https://oss-qn.yaklang.com/yakit-technical-white-paper.pdf" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link diy-link-item"><span>下载白皮书</span></a><a href="https://github.com/yaklang" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link diy-link-item"><span>Github</span></a><div class="languageSwitcher"><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4163" width="20" height="20"><path d="M249.7536 378.5728c10.6496 31.6416 28.3648 59.0848 53.0432 83.2512 20.992-22.7328 36.7616-50.7904 47.0016-83.2512h-100.0448zM902.2464 191.488H511.2832L488.96 71.8848H125.952c-40.0384 0-72.6016 32.5632-72.6016 72.6016v617.1648c0 40.0384 32.5632 72.6016 72.6016 72.6016h330.9568l-26.5216 119.6032h471.9616c40.0384 0 72.6016-32.5632 72.6016-72.6016V264.192c-0.1024-40.1408-32.768-72.704-72.704-72.704zM409.3952 558.1824c-42.8032-15.7696-78.1312-35.84-106.5984-59.0848-29.7984 26.5216-67.072 46.08-110.2848 58.1632l-14.9504-24.6784c42.3936-11.1616 77.7216-27.9552 105.5744-51.712-28.7744-29.3888-48.8448-63.2832-60.1088-101.888h-40.448v-27.9552h105.5744c-6.5536-12.0832-14.9504-23.7568-24.6784-34.9184l27.9552-10.24c9.728 12.5952 18.6368 27.4432 26.5216 44.7488h100.9664v27.9552h-40.448c-13.0048 40.0384-31.6416 73.5232-56.32 100.5568 27.4432 21.9136 61.8496 40.0384 102.4 54.8864 0.1024 0.2048-15.1552 24.1664-15.1552 24.1664z m529.1008 322.56a36.352 36.352 0 0 1-36.352 36.352H475.9552l18.1248-83.2512h136.2944l-77.7216-433.2544-0.4096 2.3552-3.2768-17.3056 0.9216 0.4096-28.3648-158.3104h381.1328a36.352 36.352 0 0 1 36.352 36.352v616.6528h-0.512zM643.4816 538.2144h100.1472v-26.5216h-100.1472v-53.0432h106.5984V432.128H612.2496v190.7712h141.9264v-26.5216H643.4816v-58.1632z m208.9984-57.2416c-8.3968 0-15.7696 1.3312-22.7328 5.12-6.5536 3.2768-13.0048 8.3968-18.1248 14.9504v-16.2816H781.312v138.24h30.3104v-83.2512c0.9216-11.1616 4.7104-19.5584 11.1616-25.6 5.632-5.12 12.0832-7.9872 19.5584-7.9872 20.992 0 31.1296 11.1616 31.1296 33.9968v82.432h30.3104v-85.2992c0.8192-37.6832-16.896-56.32-51.3024-56.32z" p-id="4164"></path></svg></div><div class="searchBox_fBfG"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search (Command+K)"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button class="clean-btn backToTopButton_i9tI" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh menuWithAnnouncementBar_+O1J"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/docs/intro">Yak：致力于安全能力融合的语言</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/docs/startup">搭建 Yak 语言开发环境</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">基础语法文档</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/yak-basic/cap3-stats-vars-and-exprs">Yak 语言中的语句、变量和表达式</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap4-control-flow">控制流：IF For Switch</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap5-function">函数的创建与使用</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap6-1-concurrent-and-defer">异步、并发编程和 defer 延迟</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap6-2-error-handling">Yak 语言中的错误处理</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap6-3-scope">作用域</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap6-4-modules">模块化与多文件编程</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap6-5-fuzztag">模糊文本渲染: FuzzTag</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap7-buildin-functions">使用内置工具函数</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap8-1-http">HTTP 协议与数据包处理</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap8-2-mitm">中间人攻击: MITM</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap8-3-port-n-service-scan">网络端口扫描与指纹识别</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap8-4-yaml-poc">使用 YAML 编写 PoC</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap8-5-java-hack">渗透测试 Java 应用</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist" href="#">编程实战案例</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/intro">章节介绍</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/strutils">函数库：str - 字符串工具集</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/first_servicescan">你的第一个服务扫描程序</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/codec">函数库：codec - 加密与编码</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/first_synandscanfp">高效的端口扫描：SYN+指纹扫描</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/http-basic">函数库：http - 基本 HTTP 通信</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/spacengine">网络空间引擎信息收集</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/http-advanced">函数库：poc - 专家 HTTP 库</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/concurrent">YAK 中编写&quot;多线程/多并发&quot;应用</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/yak_misc">实战1: 扫端口/子域名+指纹识别</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/fuzz-request">函数库：fuzz - 模糊测试 HTTP</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/scan_and_crawler">实战2: 指纹扫描+基础爬虫</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/fuzztag-basic">功能集：fuzztag - 模糊测试标签</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/regexp">函数库：re - 正则表达式</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/nuclei">YAK + Nuclei：语言中的漏扫</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/json">函数库：json - 优雅地处理JSON</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/fuzz_tutorial">Web Fuzz 基础</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/synscan">函数库：synscan - SYN 扫描</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/fuzz_for_more">Web Fuzz 高级教程</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/fuzztag">Fuzz Tag Playbook</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/how_to_make_poc">如何编写优秀的 PoC/Exp 👻</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/passive_scan">初探被动扫描</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/func-p">编程技巧：函数式补充语法</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/handle-scan-target">处理扫描目标与网段（批量/分组）</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/http-raw">发送 HTTP 原始数据包</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/hosts-to-cclass">处理扫描目标：C段（自动生成）</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/batch-http">批量发包: 模糊测试批量发包</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/ysoserial-demo">Java 反序列化利用链: yso(ysoserial)</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/similarity-calc">文本相似度算法：SQLMAP、 SimHash 与 SSDeep</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/vs-dir-in-py">类比 Python 中的 dir 函数</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/xpath">HTML 处理：XPATH 案例</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/risk">漏洞检测：DNSLog</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/js-otto">执行 JavaScript 代码 (otto styled)</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Yak 语言中的语句、变量和表达式</h1></header><p>从本章节开始，笔者将带领大家正式开始Yak语言的学习。本章内容包含Yak语言中语句的类型、变量的定义与使用、基本数据类型的定义与使用，复合类型以及Yak语言中出现的运算符和表达式。</p><header><h1>3.1 语句类型概览</h1></header><p>要了解一个Yak语言基础程序，需要从基本结构开始了解：</p><ol><li>文件格式：一个标准的Yak语言程序或者脚本文件，扩展名应该为“.yak”。</li><li>Yak文件中的代码：Yak代码由一个或者多个语句构成。其基本的语句之间可以通过“回车”来进行分隔，同时也支持“;”符号分隔。</li><li>语句类型：目前Yak语言的语句主要有十三种类型，每种类型都具有不同的功能：</li></ol><table><thead><tr><th>语句类型</th><th>目的</th><th>案例描述</th></tr></thead><tbody><tr><td>注释语句</td><td>提供按行的注释或整块儿注释</td><td># 号注释 # Comment 普通注释 // Comment 多行注释 /<em> Hello YakComment </em>/</td></tr><tr><td>变量声明语句</td><td>自动或强制创建一个新的变量，这个变量会对应 YakVM 编译中的一个新符号</td><td>Golang 风格 var abc = 123 强制创建变量 abc := 123 自动创建 abc = 123</td></tr><tr><td>表达式语句</td><td>执行一个表达式，例如函数调用，数值运算，字符串运算等</td><td>1+1 &quot;abc&quot;.HasPrefix(&quot;ab&quot;)</td></tr><tr><td>赋值表达式运算</td><td>赋值+表达式的简易写法</td><td>a += 1</td></tr><tr><td>代码块</td><td>主动创建一个新的定义域，执行若干行语句</td><td>a=1;   {a++; a += 12}</td></tr><tr><td>IF 控制流</td><td>支持 if / elif / else if / else 风格的 IF 语句编写</td><td>if a&gt;1 {println(&quot;Hello V1ll4n&quot;)}</td></tr><tr><td>Switch 控制流</td><td>支持 Case 多值短路特性的 Switch 语句，与 break / fallthrough 配套</td><td>switch a {case 1,2,3: println(&quot;Hello&quot;)}</td></tr><tr><td>FOR IN 循环语句</td><td>Python 风格的 For In 语句技术实现</td><td>for a in [1,2,3] {println(a)}</td></tr><tr><td>FOR RANGE   循环语句</td><td>Golang 风格的 For Range 语句技术实现</td><td>for _, a = range [1,2,3] {println(a)}</td></tr><tr><td>FOR 循环控制</td><td>经典的 C 风格三语句 FOR 循环</td><td>for i =   1; i &lt; 10; i ++ {println(i)} for {println(&quot;无限循环&quot;)}</td></tr><tr><td>Defer 延迟执行语句</td><td>Golang 风格的在函数或执行体结尾执行的语句块儿或者函数调用</td><td>defer func{ if recover() != nil {   println(&quot;Catched&quot;) }}</td></tr><tr><td>Go 并发语句</td><td>Golang 风格的并发语句</td><td>go server.Start()</td></tr><tr><td>ASSERT 断言语句</td><td>用以快速检查程序中是否有失败的问题，定义为 <code>assert &lt;expr&gt;, expr1</code></td><td><code>assert   1+1 == 2</code>, &quot;计算失败&quot;</td></tr></tbody></table><p>笔者在后续的章节中会为大家详细介绍这些语句的使用，因此读者并不需要在这一小节完全理解各个语句的实例，有一个大概的印象即可。</p><header><h1>3.2 变量与基本数据类型</h1></header><p>变量和基本数据类型是编程语言的核心概念，它们对于一门编程语言的功能和表达能力至关重要。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="321-变量的定义和使用"></a>3.2.1 变量的定义和使用<a class="hash-link" href="#321-变量的定义和使用" title="Direct link to heading">#</a></h2><p>在编程中，变量是一个相当重要的概念，是存储和引用数据的标识符。它允许编程者在程序中存储值，并根据需要对这些值进行操作和更改，同时在程序中进一步跟踪和操作数据。在Yak语言中，变量的定义和使用非常简单和直观。本章将详细介绍如何在Yak语言中定义、声明和使用变量。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="变量的定义"></a>变量的定义<a class="hash-link" href="#变量的定义" title="Direct link to heading">#</a></h3><p>在Yak语言中，要定义一个变量，编程者可以使用<code>var</code>作为关键词，<code>var</code>后使用空格作为分隔符，再写入变量名即可完成变量的生命。变量名可以是数字，字母和下划线组合，但是必须以字母或下划线作为开头。以下是一些具体示例：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Bash"><pre tabindex="0" class="prism-code language-Bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var a            // 声明变量a</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var b, c         // 声明变量b和c</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var d, e = 1, 2  // 声明变量d和e，并分别赋值为1和2</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>根据上述示例：代码中声明了四个变量：a、b、c、d和e；用户可以选择只声明变量而不赋初值，也可以在声明时直接赋初值；根据第三行的案例，用户也可以使用一个关键字<code>var</code>后跟两个变量（使用“,”）作为分隔，可以同时声明两个变量，并同时为其赋值。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="变量的赋值"></a>变量的赋值<a class="hash-link" href="#变量的赋值" title="Direct link to heading">#</a></h3><p>在声明变量并赋值的过程中，用户使用到了本书第一个操作符“赋值操作符”，写作一个“=”符号。这个符号的意义就是把右边的“值”传递给左边的“标识符”中。</p><blockquote><p>注意：这个“=”符号并不是数学中的“等于”，在计算机科学中，一般使用“==”作为“等于”使用。</p></blockquote><p>在没有<code>var</code>修饰的时候，赋值符“=”会为左边的“标识符”自动创建一个变量。这是赋值符号一个非常好用的特性。因此以下示例在Yak语言中是合理的：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Bash"><pre tabindex="0" class="prism-code language-Bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = 10           // 将变量a赋值为10</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b, c = 20, 30    // 将变量b赋值为20，变量c赋值为30</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>您可以单独给每个变量赋值，也可以同时给多个变量赋值。赋值操作符将右侧的值分配给左侧的变量。</p><p>除了“=”作为赋值符号的情况，在Yak语言中，<code>:=</code>符号组合也可以作为“赋值”功能使用，因此上述的案例可改写成新的形式：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Bash"><pre tabindex="0" class="prism-code language-Bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a := 10           // 将变量a赋值为10</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b, c := 20, 30    // 将变量b赋值为20，变量c赋值为30</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><blockquote><p>注意：“:=”的赋值和“=”自动赋值在某些情况下并不完全等价，我们在“定义域章节”中将会为大家详细介绍他们的区别。</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="变量的使用"></a>变量的使用<a class="hash-link" href="#变量的使用" title="Direct link to heading">#</a></h3><p>变量的使用非常简单，只需在需要的地方使用变量名即可。例如：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Bash"><pre tabindex="0" class="prism-code language-Bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = 42           // 给变量a赋值为42</span></span><span class="token-line" style="color:#393A34"><span class="token plain">result = a + 2  // 使用变量a进行计算，并将结果存储在result变量中</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在上述示例中，笔者使用变量<code>a</code>进行了计算：<code>+ 2</code>，并将结果存储在了<code>result</code>变量中。</p><p>综合讲到的完整的创建变量并赋值、使用变量的行为，我们可以再用一个案例来向大家展示变量的完整用法：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var x, y = 5, 10  // 定义变量x和y，并分别赋值为5和10</span></span><span class="token-line" style="color:#393A34"><span class="token plain">sum = x + y       // 使用x和y进行计算，并将结果存储在sum变量中</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dump(sum)         // 打印sum的值</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>运行上述代码将会在屏幕中输出 </p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">(int) 15</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这个示例演示了如何在Yak语言中定义、赋值和使用变量，以及如何进行基本的数学计算，希望这能帮助读者更好地理解Yak语言中变量的使用方式。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="322-基础数据类型"></a>3.2.2 基础数据类型<a class="hash-link" href="#322-基础数据类型" title="Direct link to heading">#</a></h2><p>计算机在其最基础的层面上处理的数据都是由比特构成的。但为了更高效和直观地表示和处理数据，高级编程语言提供了一系列数据类型。这些数据类型可以理解为对底层比特数据的高级抽象，可以用整数、字符串等直观的方式表示数据，而不仅仅是一堆比特。</p><p>Yak语言提供了一系列内置的数据类型，这些数据类型意味着数据的灵活性和多样性，使得编程既能利用硬件的特性，又能便捷地表达多样的数据结构。在Yak语言中，数据类型分为两类：基础数据类型和复合数据类型。</p><p>Yak语言的基本数据类型如下：</p><ul><li><code>int</code>：表示可以带正负号的整数数据类型（在Yak语言中占用的大小为64位）；</li><li><code>string</code>：用于表示一系列字符数据的，例如：<code>&quot;Hello World&quot;</code>就是一个字符串；</li><li><code>float</code>：用于表示浮点数；</li><li><code>byte</code>：等同于“无符号8位整数”，通常用来表示一个“字节”；</li><li><code>nil</code>与<code>undefined</code>一般用于表示一个未定义的变量或者空值； </li><li><code>bool</code>：表示“布尔值”，其值只有两种情况，<code>true</code>或<code>false</code>；</li></ul><p>为了方便用户更直观地理解Yak语言中的基本数据类型，笔者创建了一个表格来对比编程语言中常见的基本数据类型：</p><table><thead><tr><th>对比类型</th><th>Yak</th><th>Python</th><th>Golang</th></tr></thead><tbody><tr><td>字符串</td><td>string</td><td>string</td><td>string</td></tr><tr><td>二进制字符串</td><td>[]byte</td><td>b-string</td><td>[]byte</td></tr><tr><td>整数</td><td>int</td><td>int</td><td>int8, int16, int32, int64</td></tr><tr><td>uint8, uint16, uint32, uint64</td><td></td><td></td><td></td></tr><tr><td>浮点</td><td>float</td><td>float</td><td>float32, float64 (double)</td></tr><tr><td>空值</td><td>undefined/nil</td><td>不支持</td><td>nil</td></tr><tr><td>布尔值</td><td>bool</td><td>bool</td><td>bool</td></tr></tbody></table><p>通过以上对比，您可以更轻松地理解和掌握 Yak 的数据类型，并与其他语言进行比较。Yak 通过其丰富的数据类型，为开发者提供了便捷的方式来表达和处理各种数据。无论你需要表示一个简单的数字，还是一个复杂的数据结构，Yak 都能为你提供相应的工具和支持。在下面的章节中，我们将对数据类型进行详细的讲解。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="整数与浮点数"></a><strong>整数与浮点数</strong><a class="hash-link" href="#整数与浮点数" title="Direct link to heading">#</a></h3><p>Yak语言为开发者提供了简洁而强大的数字类型：整数 (int) 和浮点数 (float)。在这章里，我们将详细地探讨这些数字类型以及如何在 Yaklang 中使用它们。</p><blockquote><p>为了让开发者专注于“表达逻辑”，Yak语言在设计中有意避开了“整数和浮点数”的“位数”的概念，这种屏蔽的层实现的设计可以有效避免新手用户被复杂的计算机底层原理干扰。</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="整数声明"></a>整数声明<a class="hash-link" href="#整数声明" title="Direct link to heading">#</a></h4><p>在Yak语言中，声明一个整数十分简单：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Bash"><pre tabindex="0" class="prism-code language-Bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var a = 10</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>实际的编程中，除了这种基础声明之外，用户往往会遇到其他的需求，例如声明一个“二进制”、“八进制”或“十六进制”的整数；在Yak语言中，用户可以直接声明一个非十进制的整数，可以参考如下案例：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Bash"><pre tabindex="0" class="prism-code language-Bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 二进制声明</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a = 0b10</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a) // 输出: 2</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 八进制声明</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = 0100</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(b) // 输出: 64</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 普通整数声明（十进制）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">c = 100</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(c) // 输出: 100</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 十六进制声明</span></span><span class="token-line" style="color:#393A34"><span class="token plain">d = 0x10</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(d) // 输出: 16</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在声明一个非十进制整数的时候，用户只需要记住几个前缀即可：</p><ul><li><code>0b</code>意味着声明二进制整数</li><li><code>0x</code>意味着声明一个十六进制整数</li><li>单独一个<code>0</code>意味着声明一个八进制整数</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="浮点数声明"></a>浮点数声明<a class="hash-link" href="#浮点数声明" title="Direct link to heading">#</a></h4><p>与整数相似，浮点数的声明也非常直观和简单。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Bash"><pre tabindex="0" class="prism-code language-Bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = 1.5</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a) // 输出: 1.5</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = a / 0.5</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(b) // 输出: 3.0</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="数学运算"></a>数学运算<a class="hash-link" href="#数学运算" title="Direct link to heading">#</a></h4><p>Yak语言提供了一整套基础的数学运算，用户可以以此对数字进行加、减、乘、除和取余等操作：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Bash"><pre tabindex="0" class="prism-code language-Bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">println(2 + 2)    // 输出: 4</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(50 - 5*6) // 输出: 20</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(8 / 5)    // 输出: 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(17 % 3)   // 输出: 2</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="整数与浮点的互操作"></a>整数与浮点的互操作<a class="hash-link" href="#整数与浮点的互操作" title="Direct link to heading">#</a></h4><p>在Yak语言中，当整数和浮点数一起运算时，整数会被先转换为浮点数，在进行运算，这就意味着运算的结果将是一个浮点数：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Bash"><pre tabindex="0" class="prism-code language-Bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain"> a = 5 / 2.0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a)      // 输出: 2.5</span></span><span class="token-line" style="color:#393A34"><span class="token plain">printf(&quot;%T&quot;, a) // 输出: float64</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这种设计选择的好处是保证了数值计算的准确性和一致性，无论操作数是整数还是浮点数。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="布尔值类型"></a>布尔值类型<a class="hash-link" href="#布尔值类型" title="Direct link to heading">#</a></h3><p>在Yak语言中，布尔值只有两种可能的常量：<code>true</code>和<code>false</code>。这些值通常用于表示逻辑条件的真或假。以下是一个最基本的使用：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Bash"><pre tabindex="0" class="prism-code language-Bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = false</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if a &amp;&amp; b {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;won&#x27;t go here&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">} else if a || b {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;true || false == true&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>虽然至此读者并没有正式学习<code>if</code>语句，但是上述代码案例并不像影响读者理解<code>true</code>和<code>false</code>的含义。需要用户注意的是：与某些语言不同，Yak语言中的布尔值并不能直接与数值进行算术运算，因此<code>true + 1</code>在Yak语言中一般被视为“非法”。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="空值nil-与-undefined"></a>空值：nil 与 undefined<a class="hash-link" href="#空值nil-与-undefined" title="Direct link to heading">#</a></h3><p>Yak语言中引入“空值”的概念，一般来说，用户在遇到<code>nil</code>和<code>undefined</code>的时候，它们之间并没有区别，被视为等价即可，用户可以使用两个词来表示同一个概念：“这个变量没有值”。以下是一个典型案例：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Bash"><pre tabindex="0" class="prism-code language-Bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = nil</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a == undefined) // 输出: true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(b == nil)       // 输出: true</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>如上例所示，尝试访问一个未声明的变量将返回<code>nil</code>（或<code>undefined</code>），这为开发者提供了一个便捷的方法来检查一个变量是否被赋值。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="字符声明"></a>字符声明<a class="hash-link" href="#字符声明" title="Direct link to heading">#</a></h3><p>Yak语言可使用单引号来声明一个字符：使用单引号声明字符，双引号声明字符串，这样可以直观地区分字符和字符串，提高代码的可读性：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Bash"><pre tabindex="0" class="prism-code language-Bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">c = &#x27;c&#x27;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(c)   // 输出: 99 (ASCII 值)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><blockquote><p>注意：本质上单个字符的底层类型是<code>uint8</code>。</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="字符串"></a>字符串<a class="hash-link" href="#字符串" title="Direct link to heading">#</a></h3><p>在编程语言中，字符串的处理是核心部分。Yak语言中的字符串处理吸收了众多语言的最佳时间，同时加入了一些独一无二的特性，读者可以在本节中深入理解Yak语言中的字符串处理的强大能力：</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="经典字符串声明"></a>经典字符串声明<a class="hash-link" href="#经典字符串声明" title="Direct link to heading">#</a></h4><p>与大多数编程语言的行为一致，Yak可以使用双引号来声明字符串，这种声明方式简单直观，初学者可以轻易上手：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Bash"><pre tabindex="0" class="prism-code language-Bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;Hello World&quot;)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当涉及到换行、制表符或其他特殊字符时，可以使用反斜杠<code>\</code>进行转义。例如<code>\n</code>表示换行，而<code>\t</code>表示制表符。此外，也支持直接输入字符的ASCII码，提供了另一种方式来插入特殊字符：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Bash"><pre tabindex="0" class="prism-code language-Bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;Hello \nWorld&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/*</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Output:</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Hello </span></span><span class="token-line" style="color:#393A34"><span class="token plain">World</span></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="文本块声明"></a>文本块声明<a class="hash-link" href="#文本块声明" title="Direct link to heading">#</a></h4><p>当处理多行字符串时，经典的转义方式可能会显得冗长。为了解决这一问题，Yak语言引用反引号“```”，作为文本块的界定符。读者可以观察如下案例：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Bash"><pre tabindex="0" class="prism-code language-Bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">abc = `Hello World</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Hello Yak`</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(abc)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/*</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Output:</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Hello World</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Hello Yak</span></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这个案例中，用户没有输入“\n”的转义符号也可以成功换行。不仅可以轻松处理多行字符串，还省去了每行的转义工作，大大增强了代码的可读性。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="字节序列"></a>字节序列<a class="hash-link" href="#字节序列" title="Direct link to heading">#</a></h4><p>除了传统的字符串处理，Yak语言还十分注重字节数据的处理。在声明一个字符串之前使用<code>b</code>前缀修饰，可以创建一个字节序列：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Bash"><pre tabindex="0" class="prism-code language-Bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">name = b&quot;Hello World\r\nHello Yak&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dump(name)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/*</span></span><span class="token-line" style="color:#393A34"><span class="token plain">OUTPUT:</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">([]uint8) (len=22 cap=24) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> 00000000  48 65 6c 6c 6f 20 57 6f  72 6c 64 0d 0a 48 65 6c  |Hello World..Hel|</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> 00000010  6c 6f 20 59 61 6b                                 |lo Yak|</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这种声明方式本质上是把字符串当做一个字符数组来对待，读者从<code>dump</code>的输出结果中就可以看出，这个字符串的原始字符编码也会被展示出来。这种声明方式非常适用于处理网络数据包，文件I/O等场景中的“原始数据”。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="字符串格式化"></a>字符串格式化<a class="hash-link" href="#字符串格式化" title="Direct link to heading">#</a></h4><p>Yak语言使用<code>%</code>进行基本的字符串格式化。<code>%</code> 是一种传统的格式化字符串的方法，称为字符串插值（string interpolation）。在Yak语言之外的许多编程语言中都有使用，例如 C、C++、Python 等。<code>%</code> 格式化语法允许你在字符串中插入变量的值，从而创建动态字符串。这使得字符串的格式化变得既直观又灵活，同时，还支持数组和其他数据结构的直接输入。以下是使用 <code>%</code> 进行格式化的基本语法：</p><ol><li>在字符串中，使用 <code>%</code> 符号作为占位符，后跟一个或多个格式说明符，例如 <code>%d</code>（整数）、<code>%f</code>（浮点数）或 <code>%s</code>（字符串）。</li><li>在字符串之后，使用 <code>%</code> 符号和括号（可选，用于多个变量）包含要插入的变量。</li></ol><p>以下是一些使用 <code>%</code> 进行格式化的示例：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Bash"><pre tabindex="0" class="prism-code language-Bash codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">printf(&quot;Hello I am %d years old\n&quot;, 18)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;Hello %v + %05d&quot; % [&quot;World&quot;, 4])</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/*</span></span><span class="token-line" style="color:#393A34"><span class="token plain">OUTPUT:</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Hello I am 18 years old</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Hello World + 00004</span></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>根据案例，Yak语言触发代码格式化的写法主要有两种：</p><ol><li>使用传统的<code>printf</code>函数进行触发，第一个参数为需要格式化的字符串模版，其余参数为可变参数，是格式化字符串的“材料”；</li><li>使用<code>%</code>格式化操作符来操作：<code>%</code>左边为需要格式化的模版，右边为一个格式化字符串的“材料”，例如 <code>&quot;Hello %v&quot; % &quot;World&quot;</code>；如果有多个需要格式化的点，那么需要使用 <code>[]</code>来包裹，并用逗号分隔元素，例如：<code>&quot;My name is %v, I am %d years old&quot; % [&quot;John&quot;, 18]</code>。</li></ol><p>读者可能注意到了，Yak语言在字符串模版中可以使用<code>%v</code>之类的组合来标记需要字符串格式化的位置和格式，以下是在编程中常用的一些案例，用户可随时查阅并动手实践：</p><table><thead><tr><th>项</th><th>解释</th><th>代码示例</th></tr></thead><tbody><tr><td>%v</td><td>根据变量的类型自动选择格式。</td><td><code>printf(&quot;Default format: %v\n&quot;, p)</code></td></tr><tr><td>%T</td><td>输出变量的类型。</td><td><code>printf(&quot;Type of variable: %T\n&quot;, p)</code></td></tr><tr><td>%d</td><td>十进制整数。</td><td><code>printf(&quot;Decimal integer: %d\n&quot;, 42)</code></td></tr><tr><td>%b</td><td>二进制整数。</td><td><code>printf(&quot;Binary integer: %b\n&quot;, 42)</code></td></tr><tr><td>%o</td><td>八进制整数。</td><td><code>printf(&quot;Octal integer: %o\n&quot;, 42)</code></td></tr><tr><td>%x</td><td>十六进制整数，使用小写字母。</td><td><code>printf(&quot;Hexadecimal integer (lowercase): %x\n&quot;, 42)</code></td></tr><tr><td>%X</td><td>十六进制整数，使用大写字母。</td><td><code>printf(&quot;Hexadecimal integer (uppercase): %X\n&quot;, 42)</code></td></tr><tr><td>%f</td><td>浮点数，不带指数部分。</td><td><code>printf(&quot;Floating-point number: %f\n&quot;, 3.141592)</code></td></tr><tr><td>%c</td><td>ASCII码对应的字符。</td><td><code>printf(&quot;Character: %c\n&quot;, 65)</code></td></tr><tr><td>%q</td><td>带引号的字符或字符串。</td><td><code>printf(&quot;Quoted character: %q\n&quot;, 65)</code></td></tr><tr><td>%s</td><td>字符串。</td><td><code>printf(&quot;String: %s\n&quot;, &quot;Hello, world!&quot;)</code></td></tr><tr><td>%p</td><td>输出十六进制表示的内存地址或引用。</td><td><code>printf(&quot;Pointer: %p\n&quot;, &amp;p)</code></td></tr></tbody></table><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="字符串模版字面量f-string"></a>字符串模版字面量：<code>f-string</code><a class="hash-link" href="#字符串模版字面量f-string" title="Direct link to heading">#</a></h4><p>Yak 语言中的 f-string（格式化字符串字面量）是一种方便的字符串插值方法，允许在字符串中直接使用表达式。这种方法可以让你轻松地将变量和表达式的值嵌入到字符串中，而无需使用复杂的字符串拼接或格式化函数。以下是一个简化的解释和示例：</p><ol><li>定义变量： 在示例中，我们定义了两个变量，<code>a</code> 和 <code>name</code>。<code>a</code> 的值为 &quot;World&quot;，而 <code>name</code> 的值为 &quot;Yak&quot;。</li></ol><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = &quot;World&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">name = &quot;Yak&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ol><li>使用<code>f-string</code>： 要使用<code>f-string</code>，需要在字符串的前面加上一个小写的 <code>f</code>，然后在字符串内部用 <code>${}</code> 包裹需要插入的表达式。在这个例子中，我们将在字符串中插入变量 <code>a</code> 和 <code>name</code> 的值。</li></ol><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">println(f`Hello ${a}, Hello ${name}`)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ol><li>输出结果： 这段代码将输出 &quot;Hello World, Hello Yak&quot;。这是因为 f-string 会将 <code>${a}</code> 替换为变量 <code>a</code> 的值，将 <code>${name}</code> 替换为变量 <code>name</code> 的值。</li></ol><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plaintext"><pre tabindex="0" class="prism-code language-Plaintext codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">OUTPUT:</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Hello World, Hello Yak</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Yak语言中的<code>f-string</code>提供了一种简单直观的字符串插值方法，使得在字符串中嵌入变量和表达式的值变得非常简单。只需在字符串前加上一个小写的 <code>f</code>，并用 <code>${}</code> 包裹需要插入的表达式即可。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="fuzztag快速执行x-string"></a>Fuzztag快速执行：x-string<a class="hash-link" href="#fuzztag快速执行x-string" title="Direct link to heading">#</a></h4><blockquote><p>注意：本小块内容在<code>fuzztag</code>的专门章节中会详细介绍，此处只做简略叙述。</p></blockquote><p>为了更好地支持模糊测试，Yak 语言引入了 x-string（fuzztag扩展语法）。这种独特的字符串处理方式能够快速生成一系列基于模板的字符串，大大加速了模糊测试的流程：</p><p>在这个例子中，我们使用 x-string 创建一个模板，该模板将生成一个包含 1 到 10 之间的整数的字符串：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = x&quot;Fuzztag int(1-10): {{int(1-10)}}&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dump(a)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Yak 语言的字符串处理功能既丰富又灵活，同时具有高效性。无论是进行基本的字符串操作，还是处理复杂的二进制数据和模糊测试，Yak 语言都能轻松应对，成为该语言的一大亮点。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="字符串运算"></a>字符串运算<a class="hash-link" href="#字符串运算" title="Direct link to heading">#</a></h4><p>与许多编程语言相似，Yak 语言也采用加号 <code>+</code> 来进行字符串的连接。以下是一个简单的示例：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = &quot;Hello, &quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = &quot;Yak&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a + b)  // 输出：Hello, Yak</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>受 Python 语言的启发，Yak 语言引入了星号 <code>*</code> 操作，允许将字符串重复 N 次。以下是一个示例：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = &quot;powerful &quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a * 5 + &quot;yak&quot;)  // 输出：powerful powerful powerful powerful powerful yak</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Yak 语言使用索引和切片操作来创建字符串“切片”。通过方括号 <code>[]</code> 和下标，你可以轻松地获取子字符串或子元素。以下是一些示例：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = &quot;Hello, Yak&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a[0])      // 输出：H</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a[1:5])    // 输出：ello</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a[3:0:-1]) // 输出：lle</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>现在，扩展这个示例，包括 <code>a[1:]</code> 和 <code>a[:3]</code> 这样的用法，以详细介绍索引操作在 Yak 语言中的应用。</p><ul><li>省略结束索引，表示从开始索引一直到字符串末尾：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = &quot;Hello, Yak&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a[1:]) // 输出：ello, Yak</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>省略开始索引，表示从字符串开头到结束索引（不包括结束索引）：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = &quot;Hello, Yak&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a[:3]) // 输出：Hel</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>使用负数索引，表示从字符串末尾开始计算：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = &quot;Hello, Yak&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a[-3:]) // 输出：Yak</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这些示例中，我们展示了如何在 Yak 语言中连接字符串、重复字符串以及使用索引和切片来截取子字符串。这些功能使得处理字符串变得简单且直观，为学习和使用 Yak 语言的用户提供了便利。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="字符串内置方法"></a>字符串内置方法<a class="hash-link" href="#字符串内置方法" title="Direct link to heading">#</a></h4><p>为了使字符串处理更加高效，Yak语言引入了一系列内置方法。这些方法类似于Python，但进行了必要的优化和扩展，使其更符合Yak语言的设计哲学。</p><p>在这里，我们将介绍一些关于字符串类型的常用内置方法及示例。在这些示例中，我们将使用<code>assert</code>语句来确保示例代码的正确性。<code>assert</code>语句用于测试表达式的值，如果表达式为真，则程序继续执行；如果为假，则程序抛出异常并终止。这是一种简便的检查代码正确性的方法。</p><ul><li>反转字符串：将字符串进行反序。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">assert &quot;abcdefg&quot;.Reverse() == &quot;gfedcba&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>是否包含：判断字符串是否包含子字符串。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">assert &quot;abcabc&quot;.Contains(&quot;abc&quot;) == true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">assert &quot;abcabc&quot;.Contains(&quot;qwe&quot;) == false</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>替代：替代字符串中的子字符串。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">assert &quot;abcabc&quot;.ReplaceN(&quot;abc&quot;, &quot;123&quot;, 1) == &quot;123abc&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">assert &quot;abcabc&quot;.Replace(&quot;abc&quot;, &quot;123&quot;) == &quot;123123&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>分割：将字符串根据子串进行分割，得到数组。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">assert &quot;abc1abc&quot;.Split(&quot;1&quot;) == [&quot;abc&quot;, &quot;abc&quot;]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>连接：使用特定的字符串连接数组。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">assert &quot;1&quot;.Join([&quot;abc&quot;, &quot;abc&quot;]) == &quot;abc1abc&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>移除前后特定字符：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">assert &quot;pabcp&quot;.Trim(&quot;p&quot;) == &quot;abc&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>转换为大写：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">assert &quot;hello&quot;.Upper() == &quot;HELLO&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>转换为小写：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">assert &quot;HELLO&quot;.Lower() == &quot;hello&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>计算子字符串出现的次数：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">assert &quot;abcabc&quot;.Count(&quot;abc&quot;) == 2</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>查找子字符串首次出现的位置：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">assert &quot;abcabc&quot;.Find(&quot;abc&quot;) == 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">assert &quot;abcabc&quot;.Find(&quot;qwe&quot;) == -1</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>通过这些示例，读者应该大致了解Yak语言中字符串处理的大部分常用功能。这些内置方法简化了字符串操作，使其更加直观和易于理解。</p><p>包含上述描述的例子，笔者把Yak语言的字符串处理方法整理成表格，以便读者随时查阅：</p><table><thead><tr><th><strong>方法名称</strong></th><th><strong>代码案例</strong></th><th><strong>简要描述</strong></th></tr></thead><tbody><tr><td>First</td><td><code>assert &quot;hello&quot;.First() == &#x27;h&#x27;</code></td><td>获取字符串第一个字符</td></tr><tr><td>Reverse</td><td><code>assert &quot;hello&quot;.Reverse() == &quot;olleh&quot;</code></td><td>倒序字符串</td></tr><tr><td>Shuffle</td><td><code>newStr = &quot;hello&quot;.Shuffle()</code></td><td>随机打乱字符串</td></tr><tr><td>Fuzz</td><td><code>results = &quot;hello&quot;.Fuzz({&quot;params&quot;: &quot;value&quot;})</code></td><td>对字符串进行模糊处理</td></tr><tr><td>Contains</td><td><code>assert &quot;hello&quot;.Contains(&quot;ell&quot;) == true</code></td><td>判断字符串是否包含子串</td></tr><tr><td>IContains</td><td><code>assert &quot;Hello&quot;.IContains(&quot;ell&quot;) == true</code></td><td>判断字符串是否包含子串（忽略大小写）</td></tr><tr><td>ReplaceN</td><td><code>assert &quot;hello&quot;.ReplaceN(&quot;l&quot;, &quot;x&quot;, 1) == &quot;hexlo&quot;</code></td><td>替换字符串中的子串（指定替换次数）</td></tr><tr><td>ReplaceAll</td><td><code>assert &quot;hello&quot;.ReplaceAll(&quot;l&quot;, &quot;x&quot;) == &quot;hexxo&quot;</code></td><td>替换字符串中所有的子串</td></tr><tr><td>Split</td><td><code>assert &quot;hello world&quot;.Split(&quot; &quot;) == [&quot;hello&quot;, &quot;world&quot;]</code></td><td>分割字符串</td></tr><tr><td>Join</td><td><code>assert &quot; &quot;.Join([&quot;hello&quot;, &quot;world&quot;]) == &quot;hello world&quot;</code></td><td>连接字符串</td></tr><tr><td>Trim</td><td><code>assert &quot; hello &quot;.Trim(&quot; &quot;) == &quot;hello&quot;</code></td><td>去除字符串两端的cutset</td></tr><tr><td>TrimLeft</td><td><code>assert &quot; hello &quot;.TrimLeft(&quot; &quot;) == &quot;hello &quot;</code></td><td>去除字符串左端的cutset</td></tr><tr><td>TrimRight</td><td><code>assert &quot; hello &quot;.TrimRight(&quot; &quot;) == &quot; hello&quot;</code></td><td>去除字符串右端的cutset</td></tr><tr><td>HasPrefix</td><td><code>assert &quot;hello&quot;.HasPrefix(&quot;he&quot;) == true</code></td><td>判断字符串是否以prefix开头</td></tr><tr><td>RemovePrefix</td><td><code>assert &quot;hello&quot;.RemovePrefix(&quot;he&quot;) == &quot;llo&quot;</code></td><td>移除前缀</td></tr><tr><td>HasSuffix</td><td><code>assert &quot;hello&quot;.HasSuffix(&quot;lo&quot;) == true</code></td><td>判断字符串是否以suffix结尾</td></tr><tr><td>RemoveSuffix</td><td><code>assert &quot;hello&quot;.RemoveSuffix(&quot;lo&quot;) == &quot;hel&quot;</code></td><td>移除后缀</td></tr><tr><td>Zfill</td><td><code>assert &quot;42&quot;.Zfill(5) == &quot;00042&quot;</code></td><td>字符串左侧填充0</td></tr><tr><td>Rzfill</td><td><code>assert &quot;42&quot;.Rzfill(5) == &quot;42000&quot;</code></td><td>字符串右侧填充0</td></tr><tr><td>Ljust</td><td><code>assert &quot;hello&quot;.Ljust(7) == &quot;hello  &quot;</code></td><td>字符串左侧填充空格</td></tr><tr><td>Rjust</td><td><code>assert &quot;hello&quot;.Rjust(7) == &quot;  hello&quot;</code></td><td>字符串右侧填充空格</td></tr><tr><td>Count</td><td><code>assert &quot;hello&quot;.Count(&quot;l&quot;) == 2</code></td><td>统计字符串中substr出现的次数</td></tr><tr><td>Find</td><td><code>assert &quot;hello&quot;.Find(&quot;l&quot;) == 2</code></td><td>查找字符串中substr第一次出现的位置</td></tr><tr><td>Rfind</td><td><code>assert &quot;hello&quot;.Rfind(&quot;l&quot;) == 3</code></td><td>查找字符串中substr最后一次出现的位置</td></tr><tr><td>Lower</td><td><code>assert &quot;HELLO&quot;.Lower() == &quot;hello&quot;</code></td><td>将字符串转换为小写</td></tr><tr><td>Upper</td><td><code>assert &quot;hello&quot;.Upper() == &quot;HELLO&quot;</code></td><td>将字符串转换为大写</td></tr><tr><td>Title</td><td><code>assert &quot;hello world&quot;.Title() == &quot;Hello World&quot;</code></td><td>将字符串转换为Title格式</td></tr><tr><td>IsLower</td><td><code>assert &quot;hello&quot;.IsLower() == true</code></td><td>判断字符串是否为小写</td></tr><tr><td>IsUpper</td><td><code>assert &quot;HELLO&quot;.IsUpper() == true</code></td><td>判断字符串是否为大写</td></tr><tr><td>IsTitle</td><td><code>assert &quot;Hello World&quot;.IsTitle() == true</code></td><td>判断字符串是否为Title格式</td></tr><tr><td>IsAlpha</td><td><code>assert &quot;hello&quot;.IsAlpha() == true</code></td><td>判断字符串是否为字母</td></tr><tr><td>IsDigit</td><td><code>assert &quot;123&quot;.IsDigit() == true</code></td><td>判断字符串是否为数字</td></tr><tr><td>IsAlnum</td><td><code>assert &quot;hello123&quot;.IsAlnum() == true</code></td><td>判断字符串是否为字母或数字</td></tr><tr><td>IsPrintable</td><td><code>assert &quot;hello&quot;.IsPrintable() == true</code></td><td>判断字符串是否为可打印字符</td></tr></tbody></table><header><h1>3.3 复合数据类型</h1></header><p>Yak语言除了基本数据类型之外，还支持一些符合类型，它们极大地丰富了Yak语言的表现力：</p><ul><li><code>list</code>：列表（也可以叫数组，切片），与 Python 的 list 类似；</li><li><code>map</code>：一个键-值对的集合，与 Python 的 dict 类型相似；</li><li><code>channel</code>：用于在协程之间通信的数据通道；</li><li><code>var</code>：用于表示任意类型，与 Golang 的 interface{} 类型相似；</li></ul><p>同样为了方便用户直观地理解Yak语言中的复合数据类型（高级类型），笔者可以把它们放在一起与Python和Golang进行对比：</p><table><thead><tr><th>对比类型</th><th>Yak</th><th>Python</th><th>Golang</th></tr></thead><tbody><tr><td>键值组 (map/dict)</td><td>map</td><td>dict</td><td>map</td></tr><tr><td>数组/切片/列表</td><td>list</td><td>list</td><td>slice/array</td></tr><tr><td>结构体/类/接口</td><td>不支持</td><td>class</td><td>struct/interface 体系</td></tr><tr><td>数据通道</td><td>channel</td><td>不支持</td><td>channel</td></tr><tr><td>任意类型</td><td>var</td><td>object</td><td>any(interface{})</td></tr></tbody></table><p>在后续的内容会详细为大家介绍这几种非常重要的复合类型，它们是Yak语言强大的灵活性和表现力的关键。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="331-列表类型list"></a>3.3.1 列表类型：list<a class="hash-link" href="#331-列表类型list" title="Direct link to heading">#</a></h2><p>在 Yak 语言中，List 是一种动态数组，它可以存储和管理相同类型的元素。Yak 语言支持字面量声明和 <code>make</code> 语法来创建 List。接下来，笔者将详细介绍如何声明 List 以及如何对 List 进行操作。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="创建列表"></a>创建列表<a class="hash-link" href="#创建列表" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="字面量声明"></a>字面量声明<a class="hash-link" href="#字面量声明" title="Direct link to heading">#</a></h4><p>使用 <code>[var1, var2, var3...]</code> 形式快速声明一个 List。Yak 语言会根据列表内的元素类型自动推断合适的 List 类型。例如：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plaintext"><pre tabindex="0" class="prism-code language-Plaintext codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = [1, 2, 3]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(typeof(a)) // 输出：[]int</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = [&quot;qwe&quot;, &quot;asd&quot;]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(typeof(b)) // 输出：[]string</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">c = [1, 2, &quot;3&quot;]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(typeof(c)) // 输出：[]interface {}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>列表类型的自动推断规则为：</p><ul><li>如果列表内混合了不同的数据类型，那么这个列表的类型为 any。</li><li>如果列表内只有整数，类型为 int。</li><li>如果列表内既有整数又有浮点数，类型为 float。</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="按类型构建make"></a>按类型构建（make）<a class="hash-link" href="#按类型构建make" title="Direct link to heading">#</a></h4><p>Yak 语言的 List 支持使用 <code>make</code> 语法创建。例如：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plaintext"><pre tabindex="0" class="prism-code language-Plaintext codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 创建一个空的 []int 类型列表</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a = make([]int)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(typeof(a)) // 输出：[]int</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 创建一个带有2个元素的 []int 类型列表</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = make([]int, 2)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(len(b)) // 输出：2</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="列表操作"></a>列表操作<a class="hash-link" href="#列表操作" title="Direct link to heading">#</a></h3><p>Yak 语言的 List 支持一系列操作和内置函数。例如：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = [1, 2]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = [4, 5, 6]</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 列表追加</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a = append(a, 3) // a 的值变为：[1, 2, 3]</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 列表合并</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a = a + b // a 的值变为：[1, 2, 3, 4, 5, 6]</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 访问列表元素</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a[0]) // 输出：1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a[:2]) // 输出：[1, 2]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a[::-1]) // 输出：[6, 5, 4, 3, 2, 1]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>通过以上示例，读者应该已经对 Yak 语言中的 List 类型有了基本的了解。List 提供了丰富的操作和内置函数，使得处理数组变得简单直观。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="列表的内置方法"></a>列表的内置方法<a class="hash-link" href="#列表的内置方法" title="Direct link to heading">#</a></h4><p>除了上述的基本操作之外，Yak语言还提供了一套列表的“内置方法”方便用户直接对列表进行增删改查，读者可以根据下面的代码实例尝试使用Yak语言的内置方法：</p><ul><li><strong>创建和添加元素</strong>：我们首先创建一个数组 <code>a = [1, 2, 3]</code>。然后，我们可以使用 <code>Append</code> 方法在数组的末尾添加一个元素，如：<code>a.Append(4)</code>。此时，<code>a</code> 的值应该为 <code>[1, 2, 3, 4]</code>。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = [1, 2, 3]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a.Append(4)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a)  // 输出：[1, 2, 3, 4]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li><strong>获取长度和容量</strong>：我们可以使用 <code>Length</code> 方法获取数组的长度，如：<code>a.Length()</code>。此外，可以使用 <code>Capability</code> 方法获取数组的容量，如：<code>a.Capability()</code>。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">println(a.Length())   // 输出：4</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a.Capability())  // 输出：4</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li><strong>扩展数组</strong>：我们可以使用 <code>Extend</code> 方法将新的数组 <code>[5, 6]</code> 添加到原数组的末尾，如：<code>a.Extend([5, 6])</code>。此时，<code>a</code> 的值应该为 <code>[1, 2, 3, 4, 5, 6]</code>。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a.Extend([5, 6])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a)  // 输出：[1, 2, 3, 4, 5, 6]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li><strong>删除元素</strong>：我们可以使用 <code>Pop</code> 方法删除数组的最后一个元素，如：<code>a.Pop()</code>。此外，我们还可以指定索引来删除数组中的特定元素，如：<code>a.Pop(1)</code>。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = [1, 2, 3, 4]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">v = a.Pop()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a)  // 输出：[1, 2, 3]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(v)  // 输出：4</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li><strong>插入元素</strong>：我们可以使用 <code>Insert</code> 方法在数组的特定位置插入一个元素，如：<code>a.Insert(1, 2)</code>。此时，<code>a</code> 的值应该为 <code>[1, 2, 3, 4]</code>。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = [1, 3, 4]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a.Insert(1, 2)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a)  // 输出：[1, 2, 3, 4]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li><strong>移除元素</strong>：我们可以使用 <code>Remove</code> 方法移除数组中的一个元素，如：<code>a.Remove(1)</code>。此时，<code>a</code> 的值应该为 <code>[2, 1]</code>。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = [1, 2, 1]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a.Remove(1)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a)  // 输出：[2, 1]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li><strong>反转数组</strong>：我们可以使用 <code>Reverse</code> 方法将数组的内容反转，如：<code>a.Reverse()</code>。此时，<code>a</code> 的值应该为 <code>[4, 3, 2, 1]</code>。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = [1, 2, 3, 4]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a.Reverse()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a)  // 输出：[4, 3, 2, 1]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li><strong>排序数组</strong>：我们可以使用 <code>Sort</code> 方法对数组进行排序，如：<code>a.Sort()</code>。此时，<code>a</code> 的值应该为 <code>[1, 2, 3, 4]</code>。我们还可以通过传递 <code>true</code> 参数进行降序排序，如：<code>a.Sort(true)</code>。此时，<code>a</code> 的值应该为 <code>[4, 3, 2, 1]</code>。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = [4, 1, 3, 2]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a.Sort()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a)  // 输出：[1, 2, 3, 4]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li><strong>映射数组</strong>：我们可以使用 <code>Map</code> 方法对数组中的每一个元素进行函数操作，如：<code>a.Map(func (v) {return v + 1})</code>。此时，<code>a</code> 的值应该为 <code>[2, 3, 4, 5]</code>。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = [1, 2, 3, 4]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a = a.Map(func (v) {return v + 1})</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a)  // 输出：[2, 3, 4, 5]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li><strong>过滤数组</strong>：我们可以使用 <code>Filter</code> 方法对数组中的每一个元素进行过滤，如：<code>a.Filter(func (v) {return v &gt; 2})</code>。此时，<code>a</code> 的值应该为 <code>[3, 4]</code>。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = [1, 2, 3, 4]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a = a.Filter(func (v) {return v &gt; 2})</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a)  // 输出：[3, 4]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li><strong>清空数组</strong>：我们可以使用 <code>Clear</code> 方法移除所有元素，如：<code>a.Clear()</code>。此时，<code>a</code> 的值应该为 <code>[]</code>。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = [1, 2, 3]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a.Clear()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a)  // 输出：[]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>笔者将常见的内置方法展示在下面表格中，读者可以自行查阅并尝试构建测试案例学习使用：</p><table><thead><tr><th><strong>方法名</strong></th><th><strong>参数</strong></th><th><strong>描述</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>Append/Push</td><td>element</td><td>往数组/切片最后追加元素</td><td><code>a.Append(1)</code> 或 <code>a.Push(1)</code></td></tr><tr><td>Pop</td><td>(可选) index</td><td>弹出数组/切片的一个元素，默认为最后一个</td><td><code>a.Pop()</code> 或 <code>a.Pop(1)</code></td></tr><tr><td>Extend/Merge</td><td>newSlice</td><td>用一个新的数组/切片扩展原数组/切片</td><td><code>a.Extend(b)</code> 或 <code>a.Merge(b)</code></td></tr><tr><td>Length/Len</td><td>无</td><td>获取数组/切片的长度</td><td><code>a.Length()</code> 或 <code>a.Len()</code></td></tr><tr><td>Capability/Cap</td><td>无</td><td>获取数组/切片的容量</td><td><code>a.Capability()</code> 或 <code>a.Cap()</code></td></tr><tr><td>StringSlice</td><td>无</td><td>将数组/切片转换成 []string</td><td><code>a.StringSlice()</code></td></tr><tr><td>GeneralSlice</td><td>无</td><td>将数组/切片转换成最泛化的 Slice 类型 []any ([]interface{})</td><td><code>a.GeneralSlice()</code></td></tr><tr><td>Shift</td><td>无</td><td>从数据开头移除一个元素</td><td><code>a.Shift()</code></td></tr><tr><td>Unshift</td><td>element</td><td>从数据开头增加一个元素</td><td><code>a.Unshift(1)</code></td></tr><tr><td>Map</td><td>mapFunc</td><td>对数组/切片中的每个元素进行指定的函数运算，返回结果</td><td><code>a.Map(func(i) { return i * 2 })</code></td></tr><tr><td>Filter</td><td>filterFunc</td><td>根据指定的函数过滤数组/切片中的元素，返回结果</td><td><code>a.Filter(func(i) { return i &gt; 3 })</code></td></tr><tr><td>Insert</td><td>index, element</td><td>在指定位置插入元素</td><td><code>a.Insert(1, 2)</code></td></tr><tr><td>Remove</td><td>element</td><td>移除数组/切片的第一次出现的元素</td><td><code>a.Remove(1)</code></td></tr><tr><td>Reverse</td><td>无</td><td>反转数组/切片</td><td><code>a.Reverse()</code></td></tr><tr><td>Sort</td><td>(可选) reverse</td><td>对数组/切片进行排序，可选参数 reverse 决定是否反向排序</td><td><code>a.Sort()</code> 或 <code>a.Sort(true)</code></td></tr><tr><td>Clear</td><td>无</td><td>清空数组/切片</td><td><code>a.Clear()</code></td></tr><tr><td>Count</td><td>element</td><td>计算数组/切片中元素数量</td><td><code>a.Count(1)</code></td></tr><tr><td>Index</td><td>indexInt</td><td>返回数组/切片中第n个元素</td><td><code>a.Index(1)</code></td></tr></tbody></table><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="332-字典类型map"></a>3.3.2 字典类型：map<a class="hash-link" href="#332-字典类型map" title="Direct link to heading">#</a></h2><p>在编程世界中，字典是我们经常使用的一种数据结构，它允许我们存储键值对。在Yak语言中，你会发现字典非常灵活且强大，支持多种创建、访问和操作方法。这一章节，笔者将详细解析Yak语言中的字典类型，帮助你在Yak程序中高效地使用字典。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="创建字典"></a>创建字典<a class="hash-link" href="#创建字典" title="Direct link to heading">#</a></h3><p>在Yak语言中，你可以直接使用字面量形式创建字典。例如，你可以创建一个基于字符串键和整数值的字典，如下所示：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">m = {&quot;a&quot;: 1, &quot;b&quot;: 2}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(typeof(m)) // 输出：map[string]int</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>你也可以创建一个基于字符串键和字符串值的字典，或者使用混合类型的键和值：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">m2 = {&quot;a&quot;:&quot;b&quot;, &quot;c&quot;:&quot;d&quot;}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(typeof(m2)) // 输出：map[string]string</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">m3 = {&quot;a&quot;: 1, &quot;b&quot;: 1.5, &quot;c&quot;: &quot;d&quot;}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(typeof(m3)) // 输出：map[string]interface{}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">m4 = {1: 2, &quot;3&quot;:&quot;4&quot;, &quot;5&quot;: 6.0}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(typeof(m4)) // 输出：map[interface{}]interface{}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>除了字面量创建法，你还可以使用 <code>make</code> 函数来创建和初始化字典。这提供了一种更加直观的方式。以下是创建一个空字典和指定字典初始容量的例子：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = make(map[string]int)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a[&quot;a&quot;] = 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a) // 输出：map[a:1]</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = make(map[string]var, 2)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b[&quot;x&quot;] = true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b[&quot;y&quot;] = &quot;yak&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(b) // 输出：map[x:true y:yak]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="字典的基础操作"></a>字典的基础操作<a class="hash-link" href="#字典的基础操作" title="Direct link to heading">#</a></h3><p>在Yak语言中，你会发现字典的使用方式与Go语言非常相似。以下是一些常用的操作示例：</p><p>首先，我们创建一个字典：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = {&quot;a&quot;: 234, &quot;b&quot;: &quot;sasdfasdf&quot;, &quot;ccc&quot;: &quot;13&quot;}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>获取字典的长度：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;len(a): &quot;, len(a)) // 输出：len(a):  3</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>获取字典中的值：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">println(`a[&quot;b&quot;]: `, a[&quot;b&quot;]) // 输出：a[&quot;b&quot;]:  sasdfasdf</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(`a[&quot;b&quot;]: `, a.b) // 输出：a[&quot;b&quot;]:  sasdfasdf</span></span><span class="token-line" style="color:#393A34"><span class="token plain">v = &quot;b&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(`a.$v: `, a.$v) // 输出：a.$v:  sasdfasdf</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><blockquote><p>这行代码可能对新手来说比较难理解：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">println(`a.$v: `, a.$v) // 输出：a.$v:  sasdfasdf</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这行代码中，<code>println</code>是一个打印函数，用于输出信息到控制台。<code>a.$v</code>是一个特殊的语法，用于在字典<code>a</code>中查找键为<code>v</code>的值。在这个例子中，<code>v</code>的值为&quot;b&quot;，所以<code>a.$v</code>就等同于<code>a[&quot;b&quot;]</code>，结果是&quot;sasdfasdf&quot;。</p><p>这种使用变量名作为键来访问字典值的方式在许多编程语言中都有应用，例如JavaScript。这种方式非常灵活，可以在运行时动态地决定要访问的键。</p></blockquote><p>如果尝试获取字典中不存在的值，Yak语言会让取值变为<code>undefined</code>，但是如果你想使用默认值来代替<code>undefined</code>，这仍然是可以做到的：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = {&quot;a&quot;: 234, &quot;b&quot;: &quot;sasdfasdf&quot;, &quot;ccc&quot;: &quot;13&quot;}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">assert a[&quot;non-existed-key&quot;] == undefined</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">f = &quot;f&quot; in a ? a[&quot;f&quot;] : &quot;fffff&quot; // f 的值为 (string) (len=5) &quot;fffff&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">g = get(a, &quot;g&quot;, &quot;ggggg&quot;)        // g 的值为 (string) (len=5) &quot;ggggg&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>添加或修改字典中的值：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = {}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 为字典添加三个键值对</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a[&quot;e&quot;], a[&quot;f&quot;], a[&quot;g&quot;] = 4, 5, 6</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/*</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a:</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">(map[string]interface {}) (len=3) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> (string) (len=1) &quot;e&quot;: (int) 4,</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> (string) (len=1) &quot;f&quot;: (int) 5,</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> (string) (len=1) &quot;g&quot;: (int) 6</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>除了使用索引调用的方式之外，Yak语言还支持直接使用“成员字段” 的方式使用，因此上述代码等价于：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = {}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 为字典添加三个键值对</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a.e, a.f, a.g = 4, 5, 6</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/*</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a:</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">(map[string]interface {}) (len=3) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> (string) (len=1) &quot;e&quot;: (int) 4,</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> (string) (len=1) &quot;f&quot;: (int) 5,</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> (string) (len=1) &quot;g&quot;: (int) 6</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>删除字典中的键：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">delete(a, &quot;b&quot;)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>判断键是否存在于字典中：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">if a[&quot;b&quot;] != nil {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;key b in a&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if &quot;b&quot; in a {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;key b in a&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>获取字典中所有的键：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">v = a.Keys()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">v.Sort()</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>获取字典中所有的值：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">v = a.Values()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">v.Sort()</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>遍历字典中所有的键值对：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">for k, v in a.Items() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert k in [&quot;a&quot;,&quot;b&quot;]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert v in [1,2]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>使用函数遍历字典中所有的键值：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a.ForEach(func(k,v){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert k in [&quot;a&quot;,&quot;b&quot;]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert v in [1,2]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="字典的内置方法"></a>字典的内置方法<a class="hash-link" href="#字典的内置方法" title="Direct link to heading">#</a></h4><p>和列表类似，在Yak语言中，字典也可以使用内置方法来实现</p><table><thead><tr><th><strong>方法名</strong></th><th><strong>参数</strong></th><th><strong>描述</strong></th><th><strong>代码实例</strong></th></tr></thead><tbody><tr><td>Keys</td><td>无</td><td>获取所有元素的key</td><td><code>keys = myMap.Keys()</code></td></tr><tr><td>Values</td><td>无</td><td>获取所有元素的value</td><td><code>values = myMap.Values()</code></td></tr><tr><td>Entries / Items</td><td>无</td><td>获取所有元素的entity</td><td><code>entries = myMap.Entries()</code> 或 <code>items = myMap.Items()</code></td></tr><tr><td>ForEach</td><td>handler</td><td>遍历元素</td><td><code>myMap.ForEach(func(k, v) { println(k, v) })</code></td></tr><tr><td>Set</td><td>key, value</td><td>设置元素的值，如果key不存在则添加</td><td><code>myMap.Set(&quot;newKey&quot;, &quot;newValue&quot;)</code></td></tr><tr><td>Remove / Delete</td><td>key</td><td>移除一个值</td><td><code>myMap.Remove(&quot;keyToRemove&quot;)</code> 或 <code>myMap.Delete(&quot;keyToRemove&quot;)</code></td></tr><tr><td>Has / IsExisted</td><td>key</td><td>判断map元素中是否包含key</td><td><code>exists = myMap.Has(&quot;keyToCheck&quot;)</code> 或 <code>exists = myMap.IsExisted(&quot;keyToCheck&quot;)</code></td></tr><tr><td>Length / Len</td><td>无</td><td>获取元素长度</td><td><code>length = myMap.Length()</code> 或 <code>length = myMap.Len()</code></td></tr></tbody></table><p>这些方法都是通过 <code>myMap</code> 这个字典实例进行调用的，你需要将 <code>myMap</code> 替换为你自己的字典实例名。另外，这些方法的具体实现可能会因为Yak语言的版本或实现差异而有所不同。如果在实际使用中遇到问题，建议查阅相关的Yak语言文档或者参考源代码。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="333-通道类型channel"></a>3.3.3 <strong>通道类型：channel</strong><a class="hash-link" href="#333-通道类型channel" title="Direct link to heading">#</a></h2><p>在并发编程中，多任务间如何安全、高效地交换数据是一个重要的问题。Yak语言引入了一种特殊的数据类型 - channel，它就像是一个邮局，可以帮助不同任务（也叫协程）之间轻松地发送和接收数据。本章节将探讨Yak中的channel，帮助读者更好地理解和使用这个强大的工具。</p><blockquote><p>注意：Yak语言中的并发笔者在后续的章节中会为读者详细介绍，本小节内容更深入的channel的使用，读者可以在后续的章节中找到更多案例；</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="创建与声明"></a><strong>创建与声明</strong><a class="hash-link" href="#创建与声明" title="Direct link to heading">#</a></h3><p>在Yak中，可以使用make函数来创建一个新的channel。这就像是开设一个新的邮局，用于发送和接收包裹。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">ch := make(chan int)      // 创建一个没有存储空间的int类型的channel</span></span><span class="token-line" style="color:#393A34"><span class="token plain">ch2 := make(chan var, 2)  // 创建一个有2个存储空间的var类型的channel</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="channel-的基本操作"></a>Channel 的基本操作：<a class="hash-link" href="#channel-的基本操作" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="读写数据"></a><strong>读写数据</strong><a class="hash-link" href="#读写数据" title="Direct link to heading">#</a></h4><p>将数据写入channel就像是将包裹寄出，非常简单。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">ch &lt;- 1      // 将一个整数1寄出到ch，但是因为 ch 在上文创建时没有声明存储空间，这里会阻塞</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>上述案例一般会阻塞（或者描述为“卡住”），这是因为 ch 并没有存储空间，如果读者使用下面的代码，将不会阻塞，因为 ch2 中包含两个存储空间，在存储空间填满之前，写入数据将不会是阻塞的。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI JSON"><pre tabindex="0" class="prism-code language-JSON codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">ch2 &lt;- &quot;a&quot;   // 将一个字符串寄出到ch2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">ch2 &lt;- 0     // 将一个整数0寄出到ch2</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>从channel中读取数据就像是从邮局取走包裹。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">v := &lt;-ch    // 从ch取走一个包裹</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>同时，Yak还支持检查取走包裹是否成功的特性，这是通过返回两个值来实现的。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">v, ok := &lt;-ch</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if ok {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;取走成功，值为:&quot;, v)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">} else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;邮局已关闭&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="channel的属性"></a><strong>Channel的属性</strong><a class="hash-link" href="#channel的属性" title="Direct link to heading">#</a></h4><p>Yak提供了一些内置的函数来检查channel的当前状态。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">len(ch2)   // 查看ch2中还有多少个包裹</span></span><span class="token-line" style="color:#393A34"><span class="token plain">cap(ch2)   // 查看ch2最多能存放多少个包裹</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="关闭channel"></a><strong>关闭Channel</strong><a class="hash-link" href="#关闭channel" title="Direct link to heading">#</a></h4><p>当笔者不再需要发送更多的数据时，应该关闭channel。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">close(ch2)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>关闭后的channel不能再寄出数据，但仍然可以从中取走数据。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="遍历channel"></a><strong>遍历Channel</strong><a class="hash-link" href="#遍历channel" title="Direct link to heading">#</a></h4><p>与其他数据结构一样，读者可以使用for循环来取走channel中的所有包裹。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">for v = range ch2 {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;从ch2取走:&quot;, v)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><header><h1>3.4 类型转换</h1></header><p>在了解完Yak语言中强大的数据类型系统之后，读者应该发现在数据类型或复合类型中，或多或少都存在一些“类型转换”问题，例如：</p><ul><li>整数遭遇浮点数的时候，会被当成浮点数一样处理；</li><li>一个列表在创建时：Yak语言会根据传入的类型自动选择合适的复合类型来构建列表；同样的事情也发生在“字典”中；</li></ul><p>在编程的过程中，读者可能会遇到需要将一种类型的数据转换为另一种类型的情况。为了解决这种需求，Yak语言提供了一套方便、灵活且强大的类型转换机制。在这一章，笔者将详细介绍如何在Yak语言中进行类型转换，以及这些转换的内部细节和注意事项。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="341-隐式类型转换"></a>3.4.1 <strong>隐式类型转换</strong><a class="hash-link" href="#341-隐式类型转换" title="Direct link to heading">#</a></h2><p>在某些操作中，Yak会自动进行类型转换，就像一个聪明的翻译员，自动帮你把不同的语言翻译成你想要的语言。这种情况通常发生在调用某些内置函数时，Yak会检查变量类型并进行隐式类型转换。转换的优先级为：byte(uint8) &lt; int &lt; float。</p><p>一般作为用户来说，不需要额外关注“隐式类型转换”，但是Yak语言有一些特殊的隐式类型转换需要用户有一个基本印象：在Yak语言中，<strong>字符串一般来说和字符序列基本可以互相隐式转换</strong>，在需要的时候他会作为最合适的类型出现。这屏蔽掉了很多因为字符序列和字符串混用导致的编程Bug。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="342-显式类型转换"></a>3.4.2 <strong>显式类型转换</strong><a class="hash-link" href="#342-显式类型转换" title="Direct link to heading">#</a></h2><p>除了隐式类型转换，Yak还支持显式类型转换，就像是你直接告诉翻译员你想要的语言一样。这是通过所谓的“伪函数”来实现的。例如：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = &quot;123&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">aInt = int(a)    // 显式类型转换</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在上面的例子中，字符串&quot;123&quot;被转换为整数123。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="类型转换方案"></a><strong>类型转换方案</strong><a class="hash-link" href="#类型转换方案" title="Direct link to heading">#</a></h3><p>下表列出了Yak语言支持的各种类型转换，以及这些转换的具体细节：</p><table><thead><tr><th>原类型\目标类型</th><th>int</th><th>bool</th><th>float</th><th>byte</th><th>string</th><th>var</th></tr></thead><tbody><tr><td>int</td><td>-</td><td>非0为真</td><td>直接转，无信息丢失</td><td>可能会有信息丢失</td><td>等同于 sprintf(&quot;%d&quot;,num)</td><td>-</td></tr><tr><td>bool</td><td>真为1，假为0</td><td>-</td><td>真为1，假为0</td><td>真为1，假为0</td><td>&quot;true&quot;和&quot;false&quot;</td><td>-</td></tr><tr><td>float</td><td>只保留整数部分</td><td>非0为真</td><td>-</td><td>只保留整数部分</td><td>等同于 sprintf(&quot;%f&quot;,num)</td><td>-</td></tr><tr><td>byte</td><td>直接转，无信息丢失</td><td>非0为真</td><td>直接转，无信息丢失</td><td>-</td><td>等同于 sprintf(&quot;%d&quot;,num)</td><td>-</td></tr><tr><td>string</td><td>解析字符串内的数据，失败则会抛出错误</td><td>同左</td><td>同左</td><td>同左</td><td>-</td><td>-</td></tr><tr><td>var</td><td>var类型变量可以储存任意类型数据，可以通过强制类型转换转回原类型</td><td>同左</td><td>同左</td><td>同左</td><td>同左</td><td>-</td></tr></tbody></table><p>下面的教程将以表格中的类型转换为例，展示如何进行各种类型的转换：</p><ol><li><strong>1. int转其他类型</strong></li></ol><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">num = 10</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = bool(num)                     // 非0为真</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dump(b)                           // 输出: (bool) true</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">f = float(num)                    // 直接转，无信息丢失</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;%T %.1f&quot; % [f, f])       // 输出: float64 10.0</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">s = string(num)                   // 等同于 sprintf(&quot;%d&quot;,num)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dump(s)                           // 输出: (string) (len=2) &quot;10&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>注意：int转byte可能会有信息丢失。</p><ol><li><strong>2. bool转其他类型</strong></li></ol><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">b = true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">n = int(b)       // 真为1，假为0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(n)       // 输出: 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">f = float(b)     // 真为1，假为0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(f)       // 输出: 1.0</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">s = string(b)    // &quot;true&quot;和&quot;false&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(s)       // 输出: &quot;true&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>注意：bool转byte，真为1，假为0。</p><ol><li><strong>3. float转其他类型</strong></li></ol><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">f = 10.5</span></span><span class="token-line" style="color:#393A34"><span class="token plain">n = int(f)       // 只保留整数部分</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(n)       // 输出: 10</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = bool(f)      // 非0为真</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(b)       // 输出: true</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">s = string(f)    // 等同于 sprintf(&quot;%f&quot;,num)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(s)       // 输出: &quot;10.5&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>注意：float转byte只保留整数部分。</p><ol><li><strong>4. byte转其他类型</strong></li></ol><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">b = byte(10)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">n = int(b)       // 直接转，无信息丢失</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(n)       // 输出: 10</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">f = float(b)     // 直接转，无信息丢失</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dump(f)          // 输出: (float64) 10</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">s = string(b)    // 等同于 sprintf(&quot;%d&quot;,num)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(s)       // 输出: &quot;10&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>注意：byte转bool，非0为真。</p><ol><li><strong>5. string转其他类型</strong></li></ol><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">s = &quot;123&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">n = int(s)       // 解析字符串内的数据，失败则会抛出错误</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(n)       // 输出: 123</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = bool(s)      // 解析字符串内的数据，失败则会抛出错误</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(b)       // 输出: true</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">f = float(s)     // 解析字符串内的数据，失败则会抛出错误</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dump(f)          // 输出: (float64) 123</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>注意：string转byte也需要解析字符串内的数据。</p><ol><li><strong>6. var转其他类型</strong></li></ol><p>var类型变量可以储存任意类型数据，可以通过强制类型转换转回原类型。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">v = var(123)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">n = int(v)       // 强制类型转换</span></span><span class="token-line" style="color:#393A34"><span class="token plain">dump(n)          // 输出：(int) 123</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>注意：var转其他类型都需要通过强制类型转换。</p><p>希望这个教程能帮助读者更好地理解和使用Yak语言中的类型转换。</p><header><h1>3.5 表达式与运算符</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="351-基本概念"></a>3.5.1 基本概念<a class="hash-link" href="#351-基本概念" title="Direct link to heading">#</a></h2><p>在编程的世界中，读者会频繁地遇到各种计算和操作，这就需要理解运算符和表达式的使用。在 Yak 语言中，运算符是一种特殊的符号，被用来执行各种计算和操作，例如加法、减法、乘法、除法、比较、逻辑操作等。表达式则是由一个或多个运算符和操作数（如变量或字面量）组成的代码片段，它能够计算出一个值。</p><p>以 <code>a + b</code> 为例，这就是一个表达式，其中 <code>+</code> 是运算符，<code>a</code> 和 <code>b</code> 是操作数。这个表达式的值就是 <code>a</code> 和 <code>b</code> 的和。</p><p>理解运算符和表达式是学习任何编程语言的基础，因为它们是构成编程语言的基本元素。在 Yak 语言中，读者会遇到各种不同类型的运算符，包括算术运算符、比较运算符、逻辑运算符、位运算符、赋值运算符等。这些运算符的优先级和结合性决定了表达式的计算顺序。</p><p>对于编程新手来说，理解表达式的关键在于理解它是如何计算出一个值的。可以将表达式视为一个简单的数学公式，它由运算符和操作数组成，运算符定义了操作数如何组合以计算出一个值。例如，在表达式 <code>3 + 4 * 2</code> 中，由于乘法运算符的优先级高于加法运算符，所以首先计算 <code>4 * 2</code> 得到 <code>8</code>，然后再与 <code>3</code> 相加，得到最终结果 <code>11</code>。</p><p>在实际编程中，读者可能会遇到更复杂的表达式，例如包含函数调用或条件运算符的表达式。但是，无论表达式多么复杂，其核心都是由运算符和操作数组成，并按照一定的优先级和结合性规则进行计算。</p><p>理解和掌握运算符和表达式是编程的基础，它能够帮助读者更好地理解和编写代码，解决实际问题。笔者在这个章节中将详细介绍 Yak 语言中的运算符和表达式。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="352-运算符"></a>3.5.2 运算符<a class="hash-link" href="#352-运算符" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="基础运算符"></a>基础运算符<a class="hash-link" href="#基础运算符" title="Direct link to heading">#</a></h3><p>在Yak语言中，基础的数学运算运算符包括加(&#x27;+&#x27;)、减(&#x27;-&#x27;)、乘(&#x27;*&#x27;)、除(&#x27;/&#x27;)，这些运算符的使用方法与我们在数学中的使用方法相同。例如，你可以写出如下的表达式：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">result = 1 + 4 * 5</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>此外，Yak语言也支持取余数(&#x27;%&#x27;)操作，这个操作在处理诸如“每隔一定数量的循环”等问题时非常有用。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="赋值运算符"></a><strong>赋值运算符</strong><a class="hash-link" href="#赋值运算符" title="Direct link to heading">#</a></h3><p>在Yak语言中，赋值运算符有两种形式：&#x27;=&#x27;和&#x27;:=&#x27;。它们的作用是一样的，都是将右侧的值赋给左侧的变量。例如：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b := 2</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这两行代码都是有效的，它们分别将1和2赋值给了变量a和b。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="位运算"></a><strong>位运算</strong><a class="hash-link" href="#位运算" title="Direct link to heading">#</a></h3><p>Yak语言支持一系列的位运算，包括按位与(&#x27;&amp;&#x27;)、按位或(&#x27;|&#x27;)、按位异或(&#x27;^&#x27;)、按位清零(&#x27;&amp;^&#x27;)、左移(&#x27;&lt;&lt;&#x27;)、右移(&#x27;&gt;&gt;&#x27;)。这些运算符在处理二进制数据时非常有用。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="赋值"></a><strong>赋值</strong><a class="hash-link" href="#赋值" title="Direct link to heading">#</a></h3><p>在Yak语言中，你可以使用特殊的运算赋值运算符，如&#x27;+=&#x27;、&#x27;-=&#x27;、&#x27;*=&#x27;、&#x27;/=&#x27;、&#x27;%=&#x27;，它们的作用是将左侧的变量与右侧的值进行相应的运算，然后将结果赋值给左侧的变量。例如：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a += 1</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这行代码的效果等同于<code>a = a + 1</code>。</p><p>此外，Yak语言还提供了&#x27;++&#x27;和&#x27;--&#x27;运算符，它们分别表示将变量的值增加1和减少1。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="关系运算符"></a><strong>关系运算符</strong><a class="hash-link" href="#关系运算符" title="Direct link to heading">#</a></h3><p>在Yak语言中，关系运算符用于比较两个值的关系。这些运算符包括大于(&#x27;&gt;&#x27;)、小于(&#x27;&lt;&#x27;)、等于(&#x27;==&#x27;)、不等于(&#x27;!=&#x27;)、大于等于(&#x27;&gt;=&#x27;)和小于等于(&#x27;&lt;=&#x27;)。</p><p>当你需要判断一个数是否大于、小于、等于、不等于、大于等于或小于等于另一个数时，你可以使用这些运算符。以下是一些使用示例：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = 5</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = 3</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a &gt; b)  // 输出：true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a &lt; b)  // 输出：false</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a == b) // 输出：false</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a != b) // 输出：true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a &gt;= b) // 输出：true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a &lt;= b) // 输出：false</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这些例子中，你可以看到各种关系运算符的使用方法。请注意，这些运算符只能用于可以比较的类型，如数字和字符串，不能用于不能比较的类型，如数组和字典。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="逻辑运算符"></a><strong>逻辑运算符</strong><a class="hash-link" href="#逻辑运算符" title="Direct link to heading">#</a></h3><p>逻辑运算符在Yak语言中用于进行逻辑操作，包括逻辑与(&#x27;&amp;&amp;&#x27;)和逻辑或(&#x27;||&#x27;)。逻辑与运算符会在两个操作数都为真时返回真，否则返回假。逻辑或运算符会在至少有一个操作数为真时返回真，否则返回假。这两个运算符都具有短路特性，即如果左侧的操作数已经能确定整个表达式的值，那么就不会再计算右侧的操作数。以下是一些使用示例：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = false</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a &amp;&amp; b) // 输出：false</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(a || b) // 输出：true</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这个例子中，对于逻辑与运算，由于b为假，所以不论a的值是什么，整个表达式的值都为假；对于逻辑或运算，由于a为真，所以不论b的值是什么，整个表达式的值都为真。</p><p>这两个运算符都具有短路特性，即如果左侧的操作数已经能确定整个表达式的值，那么就不会再计算右侧的操作数。</p><p>让我们来看一些具体的例子：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = false</span></span><span class="token-line" style="color:#393A34"><span class="token plain">c = a &amp;&amp; println(&quot;Hello&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/*</span></span><span class="token-line" style="color:#393A34"><span class="token plain">OUTPUT:</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Hello</span></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这个例子中，<code>println(&quot;Hello&quot;)</code>是一个函数调用表达式，会打印&quot;Hello&quot;。但是，由于a为真，所以<code>a &amp;&amp; println(&quot;Hello&quot;)</code>的值取决于b。因此，程序会打印出&quot;Hello&quot;。</p><p>然而，如果我们将a改为false：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = false</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = false</span></span><span class="token-line" style="color:#393A34"><span class="token plain">c = a &amp;&amp; println(&quot;Hello&quot;) // 无输出</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这种情况下，由于a为假，所以不论<code>println(&quot;Hello&quot;)</code>的值是什么，<code>a &amp;&amp; println(&quot;Hello&quot;)</code>的值都为假。因此，程序不会打印&quot;Hello&quot;。</p><p>同样的，对于逻辑或运算符：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">c = a || println(&quot;Hello&quot;)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这种情况下，由于a为真，所以不论<code>println(&quot;Hello&quot;)</code>的值是什么，<code>a || println(&quot;Hello&quot;)</code>的值都为真。因此，程序不会打印&quot;Hello&quot;。</p><p>以上就是逻辑运算符的短路特性的一些详细示例，读者可以自行编写代码检验这个有趣的特性；</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="三元逻辑运算符"></a><strong>三元逻辑运算符</strong><a class="hash-link" href="#三元逻辑运算符" title="Direct link to heading">#</a></h3><p>三元运算符在Yak语言中的形式为<code>condition ? value1 : value2</code>。如果condition为真，则表达式的结果为value1，否则为value2。这个运算符也具有短路特性，即如果条件已经能确定整个表达式的值，那么就不会再计算其他的值。以下是一些使用示例：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = 5</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = 3</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">result = a &gt; b ? a : b</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(result) // 输出：5</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这个例子中，由于a大于b，所以<code>a &gt; b</code>为真，因此整个表达式的值为a。</p><p>值得一提的是，三元逻辑运算符仍然有短路特性，请读者再次看以下这些案例：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = 5</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = 3</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">result = a &gt; b ? println(&quot;Hello&quot;) : println(&quot;World&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 输出：Hello</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这个例子中，<code>a &gt; b</code>为真，因此整个表达式的值为<code>println(&quot;Hello&quot;)</code>。这个表达式打印&quot;Hello&quot;。请注意，<code>println(&quot;World&quot;)</code>并没有被执行，这就是短路特性的表现。</p><p>然而，如果我们将a和b的值交换：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = 3</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = 5</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">result = a &gt; b ? println(&quot;Hello&quot;) : println(&quot;World&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 输出：World</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这个例子中，<code>a &gt; b</code>为假，因此整个表达式的值为<code>println(&quot;World&quot;)</code>。这个表达式打印&quot;World&quot;。请注意，<code>println(&quot;Hello&quot;)</code>并没有被执行，这同样是短路特性的表现。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="所有支持的运算符列表"></a>所有支持的运算符列表<a class="hash-link" href="#所有支持的运算符列表" title="Direct link to heading">#</a></h3><table><thead><tr><th><strong>运算符</strong></th><th><strong>说明</strong></th><th><strong>代码示例</strong></th></tr></thead><tbody><tr><td>*</td><td>乘法</td><td><code>a = 5 * 3; // a = 15</code></td></tr><tr><td>/</td><td>除法</td><td><code>a = 15 / 3; // a = 5</code></td></tr><tr><td>%</td><td>取余</td><td><code>a = 10 % 3; // a = 1</code></td></tr><tr><td>&lt;&lt;</td><td>左移</td><td><code>a = 1 &lt;&lt; 2; // a = 4</code></td></tr><tr><td>&lt;</td><td>小于</td><td><code>result = 5 &lt; 3; // result = false</code></td></tr><tr><td>&gt;&gt;</td><td>右移</td><td><code>a = 4 &gt;&gt; 2; // a = 1</code></td></tr><tr><td>&gt;</td><td>大于</td><td><code>result = 5 &gt; 3; // result = true</code></td></tr><tr><td>&amp;</td><td>按位与</td><td><code>a = 5 &amp; 3; // a = 1</code></td></tr><tr><td>&amp;^</td><td>位清零 (AND NOT)</td><td><code>a = 5 &amp;^ 3; // a = 4</code></td></tr><tr><td>+</td><td>加法</td><td><code>a = 5 + 3; // a = 8</code></td></tr><tr><td>-</td><td>减法</td><td><code>a = 5 - 3; // a = 2</code></td></tr><tr><td>^</td><td>按位异或</td><td><code>a = 5 ^ 3; // a = 6</code></td></tr><tr><td>|</td><td>按位或</td><td>`a = 5</td></tr><tr><td>==</td><td>等于</td><td><code>result = 5 == 3; // result = false</code></td></tr><tr><td><code>&lt;=</code></td><td>小于或等于</td><td><code>result = 5 &lt;= 3; // result = false</code></td></tr><tr><td><code>&gt;=</code></td><td>大于或等于</td><td><code>result = 5 &gt;= 3; // result = true</code></td></tr><tr><td>!=</td><td>不等于</td><td><code>result = 5 != 3; // result = true</code></td></tr><tr><td><code>&lt;&gt;</code></td><td>不等于 (等价于!=)</td><td><code>result = 5 &lt;&gt; 3; // result = true</code></td></tr><tr><td>&lt;-</td><td>通道操作符</td><td><code>value = &lt;-channel; // 接收通道中的值</code></td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td><td><code>result = true &amp;&amp; false; // result = false</code></td></tr><tr><td>||</td><td>逻辑或</td><td>`result = true</td></tr><tr><td>? :</td><td>三元操作符（条件）</td><td><code>result = 5 &gt; 3 ? 5 : 3; // result = 5</code></td></tr><tr><td>=</td><td>赋值</td><td><code>a = 5;</code></td></tr><tr><td>~</td><td>函数调用时处理错误，如果出现错误则直接崩溃</td><td><code>result = someFunction()~; // 函数出错则崩溃</code></td></tr><tr><td>:=</td><td>强制赋值</td><td><code>a := 5; // 强制赋值</code></td></tr><tr><td>++</td><td>自增</td><td><code>a = 5; a++; // a = 6</code></td></tr><tr><td>--</td><td>自减</td><td><code>a = 5; a--; // a = 4</code></td></tr><tr><td>+=</td><td>加赋值</td><td><code>a = 5; a += 3; // a = 8</code></td></tr><tr><td>-=</td><td>减赋值</td><td><code>a = 5; a -= 3; // a = 2</code></td></tr><tr><td>*=</td><td>乘赋值</td><td><code>a = 5; a *= 3; // a = 15</code></td></tr><tr><td>/=</td><td>除赋值</td><td><code>a = 15; a /= 3; // a = 5</code></td></tr><tr><td>%=</td><td>取余赋值</td><td><code>a = 10; a %= 3; // a = 1</code></td></tr><tr><td>^=</td><td>异或赋值</td><td><code>a = 5; a ^= 3; // a = 6</code></td></tr><tr><td>&lt;&lt;=</td><td>左移赋值</td><td><code>a = 1; a &lt;&lt;= 2; // a = 4</code></td></tr><tr><td>&gt;&gt;=</td><td>右移赋值</td><td><code>a = 4; a &gt;&gt;= 2; // a = 1</code></td></tr><tr><td>&amp;=</td><td>与赋值</td><td><code>a = 5; a &amp;= 3; // a = 1</code></td></tr><tr><td>|=</td><td>或赋值</td><td>`a = 5; a</td></tr><tr><td>&amp;^=</td><td>位清零赋值</td><td><code>a = 5; a &amp;^= 3; // a = 4</code></td></tr><tr><td>!</td><td>逻辑非</td><td><code>result = !true; // result = false</code></td></tr><tr><td>.</td><td>访问内部成员</td><td><code>a = {&quot;foo&quot;: &quot;bar&quot;}; println(a.foo); // 输出：&quot;bar&quot; </code></td></tr><tr><td>() =&gt; {}</td><td>闭包箭头函数</td><td><code>f = () =&gt; { println(&quot;Hello, World!&quot;); }; f(); // 输出：Hello, World!</code></td></tr><tr><td>in</td><td>包含关系操作符</td><td><code>a = &quot;abcd&quot;; &quot;abc&quot; in a; // true </code></td></tr></tbody></table><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="353-运算符与表达式优先级"></a>3.5.3 运算符与表达式优先级<a class="hash-link" href="#353-运算符与表达式优先级" title="Direct link to heading">#</a></h2><p>在Yak语言中，理解运算符的优先级和执行顺序是至关重要的，因为这将影响到表达式的计算结果。运算符的优先级从高到低可以概括如下：</p><ol><li><strong>单目运算</strong>：包括类型字面量、字面量、匿名函数声明、Panic 和 Recover 函数、标识符、成员调用、切片调用、函数调用、括号表达式、闭包实例代码、make 表达式以及一元运算符表达式。</li><li><strong>二元位运算</strong>：包括位二元位运算。在 Yak 中，位运算优先级高于数学运算，例如 <code>&lt;&lt;</code>，<code>&gt;&gt;</code>，<code>&amp;</code>，<code>&amp;^</code>等就是位运算。</li><li><strong>数学运算</strong>：包括乘性运算和加性运算。乘性运算的优先级高于加性运算：<code>*</code>和<code>/</code>我们一般视为乘性运算。</li><li><strong>比较运算</strong>：包括各种比较运算符。</li><li><strong>包含运算</strong>：包括 &#x27;in&#x27; 运算符，它是初级逻辑运算，并不具备短路特征。</li><li><strong>高级逻辑运算</strong>：包括 &#x27;&amp;&amp;&#x27; 和 &#x27;||&#x27; 逻辑运算，具备短路特征。</li><li><strong>三元运算</strong>：包括 &#x27;?&#x27; 和 &#x27;:&#x27; 运算符。</li><li><strong>管道操作符</strong>：包括 &#x27;&lt;-&#x27; 运算符。</li></ol><blockquote><p>值得一提的是在Yak中“&lt;-”也是一种一元运算符，当其以 <code>&lt;- channel</code>的形式出现时，优先级等同单目运算</p></blockquote><p>理解这些运算符的优先级对于正确理解和编写 Yak 语言程序是非常重要的。在编写复杂的表达式时，笔者建议使用括号 () 来明确运算顺序，以避免可能的混淆和错误。</p><p>以下是一些代码案例，可以帮助读者理解运算符的优先级：</p><ol><li><strong>乘性运算优先级高于加性运算</strong>：</li></ol><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">a = 2 + 3 * 4; // 结果是 14，而不是 20</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这个例子中，由于乘法运算的优先级高于加法运算，所以首先执行 3 * 4 得到 12，然后再加上 2，得到结果 14。</p><ol><li><strong>位运算优先级高于乘性运算</strong>：</li></ol><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">b = 4 * 2 &amp; 3; // 结果是 8，而不是 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">b = (4 * 2) &amp; 3; // 结果是 0，而不是 8</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这个例子中，由于位运算的优先级高于乘法运算，所以首先执行 2 &amp; 3 得到 2，然后再乘以 4，得到结果 8。</p><p>使用括号先计算乘法的时候，<code>2 * 4</code>得到<code>8</code>，二进制写<code>0b1000</code>和<code>0b11</code>进行按位与计算，结果为0；</p><ol><li><strong>括号可以改变优先级</strong>：</li></ol><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">c = (2 + 3) * 4; // 结果是 20，而不是 14</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这个例子中，由于括号的存在，首先执行括号内的加法运算 2 + 3 得到 5，然后再乘以 4，得到结果 20。</p><p>这些例子说明了在 Yak 语言中，运算符的优先级和执行顺序对于正确解析和计算表达式是非常重要的。读者在编写代码时，需要特别注意这一点。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/yaklang/docs/yak-basic/cap3-stats-vars-and-exprs.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/startup"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 搭建 Yak 语言开发环境</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/yak-basic/cap4-control-flow"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">控制流：IF For Switch »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#321-变量的定义和使用" class="table-of-contents__link">3.2.1 变量的定义和使用</a><ul><li><a href="#变量的定义" class="table-of-contents__link">变量的定义</a></li><li><a href="#变量的赋值" class="table-of-contents__link">变量的赋值</a></li><li><a href="#变量的使用" class="table-of-contents__link">变量的使用</a></li></ul></li><li><a href="#322-基础数据类型" class="table-of-contents__link">3.2.2 基础数据类型</a><ul><li><a href="#整数与浮点数" class="table-of-contents__link"><strong>整数与浮点数</strong></a></li><li><a href="#布尔值类型" class="table-of-contents__link">布尔值类型</a></li><li><a href="#空值nil-与-undefined" class="table-of-contents__link">空值：nil 与 undefined</a></li><li><a href="#字符声明" class="table-of-contents__link">字符声明</a></li><li><a href="#字符串" class="table-of-contents__link">字符串</a></li></ul></li><li><a href="#331-列表类型list" class="table-of-contents__link">3.3.1 列表类型：list</a><ul><li><a href="#创建列表" class="table-of-contents__link">创建列表</a></li><li><a href="#列表操作" class="table-of-contents__link">列表操作</a></li></ul></li><li><a href="#332-字典类型map" class="table-of-contents__link">3.3.2 字典类型：map</a><ul><li><a href="#创建字典" class="table-of-contents__link">创建字典</a></li><li><a href="#字典的基础操作" class="table-of-contents__link">字典的基础操作</a></li></ul></li><li><a href="#333-通道类型channel" class="table-of-contents__link">3.3.3 <strong>通道类型：channel</strong></a><ul><li><a href="#创建与声明" class="table-of-contents__link"><strong>创建与声明</strong></a></li><li><a href="#channel-的基本操作" class="table-of-contents__link">Channel 的基本操作：</a></li></ul></li><li><a href="#341-隐式类型转换" class="table-of-contents__link">3.4.1 <strong>隐式类型转换</strong></a></li><li><a href="#342-显式类型转换" class="table-of-contents__link">3.4.2 <strong>显式类型转换</strong></a><ul><li><a href="#类型转换方案" class="table-of-contents__link"><strong>类型转换方案</strong></a></li></ul></li><li><a href="#351-基本概念" class="table-of-contents__link">3.5.1 基本概念</a></li><li><a href="#352-运算符" class="table-of-contents__link">3.5.2 运算符</a><ul><li><a href="#基础运算符" class="table-of-contents__link">基础运算符</a></li><li><a href="#赋值运算符" class="table-of-contents__link"><strong>赋值运算符</strong></a></li><li><a href="#位运算" class="table-of-contents__link"><strong>位运算</strong></a></li><li><a href="#赋值" class="table-of-contents__link"><strong>赋值</strong></a></li><li><a href="#关系运算符" class="table-of-contents__link"><strong>关系运算符</strong></a></li><li><a href="#逻辑运算符" class="table-of-contents__link"><strong>逻辑运算符</strong></a></li><li><a href="#三元逻辑运算符" class="table-of-contents__link"><strong>三元逻辑运算符</strong></a></li><li><a href="#所有支持的运算符列表" class="table-of-contents__link">所有支持的运算符列表</a></li></ul></li><li><a href="#353-运算符与表达式优先级" class="table-of-contents__link">3.5.3 运算符与表达式优先级</a></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="div--flex footer__bottom text--center"><div class="footer-logo-copyright-navigation"><div class="margin-bottom--sm"><a class="footer-link" href="/"><img src="/img/logo.png" alt="My Site Logo" class="themedImage_TMUO themedImage--light_4Vu1 footer__logo"><img src="/img/logo.png" alt="My Site Logo" class="themedImage_TMUO themedImage--dark_uzRr footer__logo"></a></div><div class="footer__copyright copyright-style"><a class="footer-a" href="https://beian.miit.gov.cn/#/Integrated/index" target="_blank">Copyright © 2025 for Yak Project. 京ICP备17047700号-3</a></div><div class="link-body"><a class="footer__link-item" href="/docs/intro" target="_blank">官方文档</a><a class="footer__link-item" href="/team">关于我们</a></div></div><div class="footer-contact-me"><a href="https://github.com/yaklang/yakit" target="_blank" class="contact-icon-body"><span role="img" aria-label="github" class="anticon anticon-github icon-style github-icon"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></span></a><div class="contact-icon-body"><span role="img" aria-label="wechat" class="anticon anticon-wechat icon-style wechat-icon"><svg viewBox="64 64 896 896" focusable="false" data-icon="wechat" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M690.1 377.4c5.9 0 11.8.2 17.6.5-24.4-128.7-158.3-227.1-319.9-227.1C209 150.8 64 271.4 64 420.2c0 81.1 43.6 154.2 111.9 203.6a21.5 21.5 0 019.1 17.6c0 2.4-.5 4.6-1.1 6.9-5.5 20.3-14.2 52.8-14.6 54.3-.7 2.6-1.7 5.2-1.7 7.9 0 5.9 4.8 10.8 10.8 10.8 2.3 0 4.2-.9 6.2-2l70.9-40.9c5.3-3.1 11-5 17.2-5 3.2 0 6.4.5 9.5 1.4 33.1 9.5 68.8 14.8 105.7 14.8 6 0 11.9-.1 17.8-.4-7.1-21-10.9-43.1-10.9-66 0-135.8 132.2-245.8 295.3-245.8zm-194.3-86.5c23.8 0 43.2 19.3 43.2 43.1s-19.3 43.1-43.2 43.1c-23.8 0-43.2-19.3-43.2-43.1s19.4-43.1 43.2-43.1zm-215.9 86.2c-23.8 0-43.2-19.3-43.2-43.1s19.3-43.1 43.2-43.1 43.2 19.3 43.2 43.1-19.4 43.1-43.2 43.1zm586.8 415.6c56.9-41.2 93.2-102 93.2-169.7 0-124-120.8-224.5-269.9-224.5-149 0-269.9 100.5-269.9 224.5S540.9 847.5 690 847.5c30.8 0 60.6-4.4 88.1-12.3 2.6-.8 5.2-1.2 7.9-1.2 5.2 0 9.9 1.6 14.3 4.1l59.1 34c1.7 1 3.3 1.7 5.2 1.7a9 9 0 006.4-2.6 9 9 0 002.6-6.4c0-2.2-.9-4.4-1.4-6.6-.3-1.2-7.6-28.3-12.2-45.3-.5-1.9-.9-3.8-.9-5.7.1-5.9 3.1-11.2 7.6-14.5zM600.2 587.2c-19.9 0-36-16.1-36-35.9 0-19.8 16.1-35.9 36-35.9s36 16.1 36 35.9c0 19.8-16.2 35.9-36 35.9zm179.9 0c-19.9 0-36-16.1-36-35.9 0-19.8 16.1-35.9 36-35.9s36 16.1 36 35.9a36.08 36.08 0 01-36 35.9z"></path></svg></span></div></div></div></div></footer></div>
<script src="/assets/js/runtime~main.1717b6bd.js"></script>
<script src="/assets/js/main.b0c9a813.js"></script>
</body>
</html>