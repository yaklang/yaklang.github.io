<!doctype html>
<html class="docs-version-current" lang="zh-CN" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Yak Program Language Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Yak Program Language Blog Atom Feed">
<link rel="search" type="application/opensearchdescription+xml" title="Yak Program Language" href="/opensearch.xml"><title data-react-helmet="true">异步、并发编程和 defer 延迟 | Yak Program Language</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://yaklang.com/docs/yak-basic/cap6-1-concurrent-and-defer"><meta data-react-helmet="true" name="docsearch:language" content="zh-CN"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="异步、并发编程和 defer 延迟 | Yak Program Language"><meta data-react-helmet="true" name="description" content="在学习完Yak语言的基础概念和语法之后，笔者将会带领大家开始Yak语言的高级编程技术，本节包含并发异步功能的使用；延迟执行，同步控制，错误处理等重要概念。"><meta data-react-helmet="true" property="og:description" content="在学习完Yak语言的基础概念和语法之后，笔者将会带领大家开始Yak语言的高级编程技术，本节包含并发异步功能的使用；延迟执行，同步控制，错误处理等重要概念。"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://yaklang.com/docs/yak-basic/cap6-1-concurrent-and-defer"><link data-react-helmet="true" rel="alternate" href="https://yaklang.com/docs/yak-basic/cap6-1-concurrent-and-defer" hreflang="zh-CN"><link data-react-helmet="true" rel="alternate" href="https://yaklang.com/en/docs/yak-basic/cap6-1-concurrent-and-defer" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://yaklang.com/docs/yak-basic/cap6-1-concurrent-and-defer" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://--dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.1b19791b.css">
<link rel="preload" href="/assets/js/runtime~main.306f7db8.js" as="script">
<link rel="preload" href="/assets/js/main.52e2f472.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="My Site Logo" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/img/logo.png" alt="My Site Logo" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"><b class="navbar__title"></b></a><a class="navbar__item navbar__link diy-link-item" href="/docs/intro">Yak 语言文档</a><a class="navbar__item navbar__link diy-link-item" href="/api-manual/intro">API 手册</a><a class="navbar__item navbar__link diy-link-item" href="/products/intro">Yakit 使用手册</a><a class="navbar__item navbar__link diy-link-item" href="/articles/intro">技术博客</a><a class="navbar__item navbar__link diy-link-item" href="/irify">静态代码分析技术</a><a class="navbar__item navbar__link diy-link-item" href="/Yaklab/yaklab">YakLab 实战手册</a><div class="navbar__item dropdown dropdown--hoverable"><a class="navbar__link diy-link-item">关于我们</a><ul class="dropdown__menu"><li><a activeclassname="dropdown__link--active" href="/team" to="/team" class="dropdown__link diy-link-item" target="_blank">关于我们</a></li><li><a activeclassname="dropdown__link--active" href="/cooperativePartner" to="/cooperativePartner" class="dropdown__link diy-link-item" target="_blank">合作伙伴</a></li></ul></div></div><div class="navbar__items navbar__items--right"><a href="https://oss-qn.yaklang.com/yakit-technical-white-paper.pdf" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link diy-link-item"><span>下载白皮书</span></a><a href="https://github.com/yaklang" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link diy-link-item"><span>Github</span></a><div class="languageSwitcher"><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4163" width="20" height="20"><path d="M249.7536 378.5728c10.6496 31.6416 28.3648 59.0848 53.0432 83.2512 20.992-22.7328 36.7616-50.7904 47.0016-83.2512h-100.0448zM902.2464 191.488H511.2832L488.96 71.8848H125.952c-40.0384 0-72.6016 32.5632-72.6016 72.6016v617.1648c0 40.0384 32.5632 72.6016 72.6016 72.6016h330.9568l-26.5216 119.6032h471.9616c40.0384 0 72.6016-32.5632 72.6016-72.6016V264.192c-0.1024-40.1408-32.768-72.704-72.704-72.704zM409.3952 558.1824c-42.8032-15.7696-78.1312-35.84-106.5984-59.0848-29.7984 26.5216-67.072 46.08-110.2848 58.1632l-14.9504-24.6784c42.3936-11.1616 77.7216-27.9552 105.5744-51.712-28.7744-29.3888-48.8448-63.2832-60.1088-101.888h-40.448v-27.9552h105.5744c-6.5536-12.0832-14.9504-23.7568-24.6784-34.9184l27.9552-10.24c9.728 12.5952 18.6368 27.4432 26.5216 44.7488h100.9664v27.9552h-40.448c-13.0048 40.0384-31.6416 73.5232-56.32 100.5568 27.4432 21.9136 61.8496 40.0384 102.4 54.8864 0.1024 0.2048-15.1552 24.1664-15.1552 24.1664z m529.1008 322.56a36.352 36.352 0 0 1-36.352 36.352H475.9552l18.1248-83.2512h136.2944l-77.7216-433.2544-0.4096 2.3552-3.2768-17.3056 0.9216 0.4096-28.3648-158.3104h381.1328a36.352 36.352 0 0 1 36.352 36.352v616.6528h-0.512zM643.4816 538.2144h100.1472v-26.5216h-100.1472v-53.0432h106.5984V432.128H612.2496v190.7712h141.9264v-26.5216H643.4816v-58.1632z m208.9984-57.2416c-8.3968 0-15.7696 1.3312-22.7328 5.12-6.5536 3.2768-13.0048 8.3968-18.1248 14.9504v-16.2816H781.312v138.24h30.3104v-83.2512c0.9216-11.1616 4.7104-19.5584 11.1616-25.6 5.632-5.12 12.0832-7.9872 19.5584-7.9872 20.992 0 31.1296 11.1616 31.1296 33.9968v82.432h30.3104v-85.2992c0.8192-37.6832-16.896-56.32-51.3024-56.32z" p-id="4164"></path></svg></div><div class="searchBox_fBfG"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search (Command+K)"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button class="clean-btn backToTopButton_i9tI" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh menuWithAnnouncementBar_+O1J"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/docs/intro">Yak：致力于安全能力融合的语言</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/docs/startup">搭建 Yak 语言开发环境</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">基础语法文档</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap3-stats-vars-and-exprs">Yak 语言中的语句、变量和表达式</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap4-control-flow">控制流：IF For Switch</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap5-function">函数的创建与使用</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/yak-basic/cap6-1-concurrent-and-defer">异步、并发编程和 defer 延迟</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap6-2-error-handling">Yak 语言中的错误处理</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap6-3-scope">作用域</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap6-4-modules">模块化与多文件编程</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap6-5-fuzztag">模糊文本渲染: FuzzTag</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap7-buildin-functions">使用内置工具函数</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap8-1-http">HTTP 协议与数据包处理</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap8-2-mitm">中间人攻击: MITM</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap8-3-port-n-service-scan">网络端口扫描与指纹识别</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap8-4-yaml-poc">使用 YAML 编写 PoC</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yak-basic/cap8-5-java-hack">渗透测试 Java 应用</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist" href="#">编程实战案例</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/intro">章节介绍</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/strutils">函数库：str - 字符串工具集</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/first_servicescan">你的第一个服务扫描程序</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/codec">函数库：codec - 加密与编码</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/first_synandscanfp">高效的端口扫描：SYN+指纹扫描</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/http-basic">函数库：http - 基本 HTTP 通信</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/spacengine">网络空间引擎信息收集</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/http-advanced">函数库：poc - 专家 HTTP 库</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/concurrent">YAK 中编写&quot;多线程/多并发&quot;应用</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/yak_misc">实战1: 扫端口/子域名+指纹识别</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/fuzz-request">函数库：fuzz - 模糊测试 HTTP</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/scan_and_crawler">实战2: 指纹扫描+基础爬虫</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/fuzztag-basic">功能集：fuzztag - 模糊测试标签</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/regexp">函数库：re - 正则表达式</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/nuclei">YAK + Nuclei：语言中的漏扫</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/json">函数库：json - 优雅地处理JSON</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/fuzz_tutorial">Web Fuzz 基础</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/synscan">函数库：synscan - SYN 扫描</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/fuzz_for_more">Web Fuzz 高级教程</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/fuzztag">Fuzz Tag Playbook</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/how_to_make_poc">如何编写优秀的 PoC/Exp 👻</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/passive_scan">初探被动扫描</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/func-p">编程技巧：函数式补充语法</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/handle-scan-target">处理扫描目标与网段（批量/分组）</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/http-raw">发送 HTTP 原始数据包</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/hosts-to-cclass">处理扫描目标：C段（自动生成）</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/batch-http">批量发包: 模糊测试批量发包</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/ysoserial-demo">Java 反序列化利用链: yso(ysoserial)</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/similarity-calc">文本相似度算法：SQLMAP、 SimHash 与 SSDeep</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/vs-dir-in-py">类比 Python 中的 dir 函数</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/xpath">HTML 处理：XPATH 案例</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/risk">漏洞检测：DNSLog</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/docs/yakexamples/js-otto">执行 JavaScript 代码 (otto styled)</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>异步、并发编程和 defer 延迟</h1></header><p>在学习完Yak语言的基础概念和语法之后，笔者将会带领大家开始Yak语言的高级编程技术，本节包含并发异步功能的使用；延迟执行，同步控制，错误处理等重要概念。</p><header><h1>6.1 协程与异步执行</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="611-什么是同步执行和异步执行"></a>6.1.1 什么是同步执行和异步执行<a class="hash-link" href="#611-什么是同步执行和异步执行" title="Direct link to heading">#</a></h2><p>一般而言，计算机程序按照代码的执行顺序分为同步执行以及异步执行。</p><p>首先，在同步异步的主要区别就是是否等待程序操作完成，程序操作是指程序中的一段完成某个功能的代码，可以包括一到多行代码，比如输出信息、读写文件、网络操作等，这都是一个程序操作。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="a-同步执行"></a>A. <strong>同步执行：</strong><a class="hash-link" href="#a-同步执行" title="Direct link to heading">#</a></h3><p>在程序运行的过程中，程序将会等待操作的完成。程序内的所有操作将会从上到下一步步执行。比如定义一段程序如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;hello&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">for i=0; i&lt;10;i++{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;in loop:&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;end loop &quot;)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在Yak代码执行的过程中程序将会按照代码内定义操作的顺序依次执行，只有前一条操作执行完成再继续执行后续的操作。比如在示例代码中，有三个操作：打印hello，循环打印十次”in loop“， 打印”end loop“。 在顺序执行的程序中将会首先打印hello，然后循环打印“in loop”， 在循环结束以后打印“end loop&quot;。</p><p>同步执行好处是顺序简单直观。</p><p>缺点是每一条代码都需要等待前面的代码执行完毕才可以执行，假如在程序中间存在一些需要时间才能完成的操作（比如文件的读取写入、进行网络请求等），那么只有在该操作完成后才可以继续执行后续的代码，整个程序会停住等待该操作的完成。这个整个程序停止等待操作完成的行为称为程序的阻塞。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="b-异步执行"></a>B. <strong>异步执行：</strong><a class="hash-link" href="#b-异步执行" title="Direct link to heading">#</a></h3><p>在异步执行中，程序执行一个操作以后，并不会等待该操作完成，而是继续执行后续的代码。当操作完成的时候将会通过各种手段通知程序该操作运行结束。</p><p>异步执行的好处在于可以有效地避免程序的阻塞，缺点是程序需要进行对操作的处理、错误处理、多操作的状态同步，将会比较复杂。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="c-同步执行和异步执行的使用"></a>C. <strong>同步执行和异步执行的使用</strong><a class="hash-link" href="#c-同步执行和异步执行的使用" title="Direct link to heading">#</a></h3><p>同步执行和异步执行都是为了完成程序的任务，只是执行顺序不同，各有优劣需要按需使用。</p><p>比如，当程序需要大量的数据读写操作，并且这些数据读写互相无关，那么使用异步执行进行读写可以使程序运行的更有效率，异步执行将会同时启动多个数据的读写操作，而不是等待一个数据读写操作完成在进行下一个。</p><p>相反，如果程序的操作之间有依赖关系，比如需要先读取配置文件，然后根据配置文件内容启动其他的操作，那么其他所有操作都需要等待配置文件读取这个操作执行，这时候需要使用同步执行。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="612-异步执行的方式"></a>6.1.2 异步执行的方式<a class="hash-link" href="#612-异步执行的方式" title="Direct link to heading">#</a></h2><p>计算机操作系统中的程序默认的执行顺序是同步执行的，因此一般情况下一般是在程序的某些互不相关的操作上使用异步执行，使得这些操作可以同时执行，并在一个合适的位置等待所有异步执行的操作执行结束，继续同步执行。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="a进程"></a>A.进程<a class="hash-link" href="#a进程" title="Direct link to heading">#</a></h3><p>在计算机操作系统中，每一个程序都是一个进程，进程之间是互相不影响的，比如浏览器和文件管理器就是两个不同的进程，他们互相毫无关系，关闭其中的一个也不会对另一个产生影响，而且两个进程都是同时在运行的。</p><p>计算机领域最早的异步编程就是使用的多进程的方式进行，也就是程序需要异步执行的操作单独开一个进程来运行，这样就可以原进程可以继续执行而不需要等待该异步操作，而异步操作也如同预期一样和原进程同时运行，操作结束以后新的进程也结束，原进程通过进程之间通讯来获得该操作的结果。这是异步执行最早的执行方案，通过这样一个效率不高的方案读者可以大致理解异步执行的程序行为。</p><p>但进程的创建、销毁是需要非常多计算机内存、运行时间的，在小型操作时使用进程实现的异步执行剩下的运行时间还不如进程的创建销毁浪费的时间多，另一方面，进程间的通讯也并不够好用。</p><p>多进程的系统中，程序也并非真正的同时运行，在单CPU计算机上，其实是通过进程的快速切换达到“在同一时间段内多个进程同时运行”的效果，这称为进程的并发，多CPU计算机可以将不同进程分配到不同CPU来达到“同一个时间点上多个进程在同时执行”的效果，也就是进程的并行。</p><p>需要注意的是，多核心单CPU的计算机其实不一定可以实现并行，如果所有的核心都使用同一套内存管理单元(MMU)和缓存机制，也只能在同一时间执行一个进程，这取决于多核CPU的硬件设计。早期的多核心CPU一般不能支持进程并发。</p><p>多进程程序是程序并行的一种形式，但是计算机操作系统中实现多进程更关注的在于进程之间的独立性，每个进程独立运行互不干扰。然而在代码编写的过程中所需要的异步执行只是避免阻塞等待提高程序效率，程序大部分时候只是需要异步计算一些数据或只是等待网络或文件读写响应，对于每一次异步执行所要求的独立性更加低，每段异步执行的代码并不需要拥有太多数据。这一需求有两种解决方案。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="b-线程与协程"></a>B. 线程与协程<a class="hash-link" href="#b-线程与协程" title="Direct link to heading">#</a></h3><p>首先在操作系统层面提供了线程，线程存在于进程内，一个进程可以启动多个线程同步执行程序，同一个进程内的多个线程之间共享地址空间，因此在使用上多线程的切换效率和通讯要比多进程更加方便。</p><p>操作系统提供的线程会在程序运行的用户态切换到操作系统内核中完成线程的切换，因此，操作系统进一步提供了用户态线程，用户态线程不需要经过操作系统内核就可以进行上下文切换。</p><p>同时在用户态也出现了协程的实现，协程与用户态线程非常类似，他们的切换都是在用户态进行的，线程是系统提供的，但是协程是用户态的代码提供的，并且协程可以由程序编写人员控制协程间的切换时机。现在活跃语言都拥有协程的实现，其中有些是通过第三方库实现有些是语言原生支持的。在Yak中提供了原生支持的协程。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="613-如何在yak中使用异步编程"></a>6.1.3 如何在Yak中使用异步编程<a class="hash-link" href="#613-如何在yak中使用异步编程" title="Direct link to heading">#</a></h2><p>在Yak中， 协程运行的基本单位是一个函数，创建协程异步执行的语法和普通的函数调用类似，只需要在开头加上&quot;go&quot;关键字即可。以下是语法示例：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">go 函数名(参数列表)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>以下是一个简单的代码案例：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">func count() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for i := 1; i &lt;= 5; i++ {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;count function:\t&quot;, i)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        sleep(1)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">count()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">for i=1; i&lt;=5; i++ {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Main function:\t&quot;, i)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    sleep(1)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">sleep(1)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这个例子中， <code>count</code>是一个函数，他的作用是循环5次打印<code>count function: i</code>， 在程序运行的时候，将会直接调用该函数，函数执行结束后将会继续执行后续代码，仍然循环5次 打印<code>Main function : i</code>， 程序将会产生以下输出：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">count function:  1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">count function:  2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">count function:  3</span></span><span class="token-line" style="color:#393A34"><span class="token plain">count function:  4</span></span><span class="token-line" style="color:#393A34"><span class="token plain">count function:  5</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Main function:   1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Main function:   2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Main function:   3</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Main function:   4</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Main function:   5</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>可以看到，一直等待到<code>count</code>函数执行结束才继续向后运行后续的循环，这就是一个同步执行的示例。</p><p>接下来，在函数调用的时候加入&quot;go&quot;关键字，将会使<code>count</code>函数异步执行, 异步执行代码示例如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">func count() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for i := 1; i &lt;= 5; i++ {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;count function:\t&quot;, i)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        sleep(1)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">go count()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">for i=1; i&lt;=5; i++ {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;Main function:\t&quot;, i)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    sleep(1)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">sleep(1)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这一示例执行结果如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">Main function:   1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">count function:  1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Main function:   2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">count function:  2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">count function:  3</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Main function:   3</span></span><span class="token-line" style="color:#393A34"><span class="token plain">count function:  4</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Main function:   4</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Main function:   5</span></span><span class="token-line" style="color:#393A34"><span class="token plain">count function:  5</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>可以看到程序将不会等待<code>count</code>的执行结束直接开始执行后续代码，而<code>count</code>函数也同样在执行，两段循环在同时执行，这就是<code>count</code>函数在异步执行的效果。</p><header><h1>6.2 延迟运行函数：Defer</h1></header><p>在编程中，有时程序希望在函数执行完成后执行一些清理操作或释放资源的操作。例如，可能需要在打开文件后关闭文件，或者在数据库操作后关闭数据库连接。延迟执行机制提供了一种方便的方式来处理这些情况。</p><p>延迟执行的基本单位也是函数，通过在函数调用前增加&quot;defer&quot;关键字，可以指定某个函数调用延迟执行，使这些函数调用将会在当前函数返回时自动执行。</p><p>这意味着无论函数中的控制流如何，这些延迟语句都会在函数返回之前被执行。这种机制可以确保无论函数是正常返回还是发生了异常, 在该函数执行完毕后都一定会进行设置好的必要清理工作。</p><blockquote><p>需要注意的是，在Yak中执行编写代码，默认是写入在主函数内的。因此在此时也可以直接使用“defer”延迟执行，在主函数内所有代码(也就是编写的代码)全部执行结束后，将会自动调用设置的延迟执行函数。</p></blockquote><p>以下为延迟执行的关键字&quot;defer&quot;语法。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">defer 函数名(参数列表)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="621-创建延迟函数"></a>6.2.1 创建延迟函数<a class="hash-link" href="#621-创建延迟函数" title="Direct link to heading">#</a></h2><p>以下是一个简单的代码样例：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;statement 1&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">defer println(&quot;statement 2&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;statement 3&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">subFunc1 = func(msg) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;in sub function 1: &quot;, msg)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">subFunc2  = func() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    defer subFunc1(&quot;call from subFunc2 defer&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    subFunc1(&quot;call from subFunc2&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">subFunc2()</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这个示例中，在主函数，程序在defer关键字进行延迟执行<code>println(&quot;statement 2&quot;)</code>这次函数调用，定义<code>subFunc1</code>和<code>subFunc2</code>两个函数， 主函数将会调用<code>subFunc2</code>函数，并在<code>subFunc2</code>中，通过普通调用和延迟调用来拿各种功能方式调用<code>subFunc1</code>函数。当运行此程序的时候，将会产生以下输出：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">statement 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">statement 3</span></span><span class="token-line" style="color:#393A34"><span class="token plain">in sub function 1:  call from subFunc2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">in sub function 1:  call from subFunc2 defer</span></span><span class="token-line" style="color:#393A34"><span class="token plain">statement 2</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>可以看到使用&quot;defer&quot;关键字进行延迟执行的函数在整个函数执行结束以后才运行， 对于主函数来说，&quot;statement 2&quot;是在所有代码执行完毕后运行的； 对于<code>subFunc2</code>来说，带有&quot;defer&quot;的调用是在该函数运行结束返回的时候运行的。其他的普通函数调用将会按照代码顺序执行。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="622-多个延迟函数"></a>6.2.2 多个延迟函数<a class="hash-link" href="#622-多个延迟函数" title="Direct link to heading">#</a></h2><p>程序可以设置多个延迟函数，这些延迟函数将会被保存在一个先入后出的栈结构内，程序结束以后，将会依次从栈中弹出执行，也就是多个函数将会优先执行后定义的函数，从后向前执行。接下来的例子将会展示这一特性：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;statement 1&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">defer println(&quot;statement 2&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">defer println(&quot;statement 3&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">defer println(&quot;statement 4&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;statement 5&quot;)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>程序运行结束以后，将会从后向前执行定义好的延迟函数，该代码示例运行结果如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">statement 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">statement 5</span></span><span class="token-line" style="color:#393A34"><span class="token plain">statement 4</span></span><span class="token-line" style="color:#393A34"><span class="token plain">statement 3</span></span><span class="token-line" style="color:#393A34"><span class="token plain">statement 2</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="623-程序出错时也会运行延迟函数"></a>6.2.3 程序出错时也会运行延迟函数<a class="hash-link" href="#623-程序出错时也会运行延迟函数" title="Direct link to heading">#</a></h2><p>程序出错时也会执行其中的延迟函数，接下来的示例将会展示这一特性：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">defer println(&quot;defer statement1 &quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a = 1 / 0 </span></span><span class="token-line" style="color:#393A34"><span class="token plain">defer println(&quot;defer statement2 &quot;)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>该程序运行到<code>1/0</code>的时候，将会触发错误，程序将崩溃，而此时已经通过defer关键字设置了&quot;defer statement1&quot;的延迟函数调用，于是，该代码示例运行结果如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">defer statement1 </span></span><span class="token-line" style="color:#393A34"><span class="token plain">Panic Stack:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">File &quot;/var/folders/8f/m14c7x3x1c55rzvk5qvvb1w00000gn/T/yaki-code-287898179.yak&quot;, in __yak_main__</span></span><span class="token-line" style="color:#393A34"><span class="token plain">--&gt; 2 a = 1 / 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">YakVM Panic: runtime error: integer divide by zero</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>值的注意的是，由于该代码在第二行<code>1/0</code>崩溃，因此第三行中的defer并没有被执行，也就不会被调用，仅有第一句中设置的延迟函数被调用了。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="624-小结"></a>6.2.4 小结<a class="hash-link" href="#624-小结" title="Direct link to heading">#</a></h2><p>函数延迟执行是一个简单但是实用的机制，通过延迟执行可以保证数据清理和资源释放操作。在本章(第六章)后续的错误处理和并发控制两个小节将会介绍更加具体两种的使用。</p><header><h1>6.3 函数的直接调用</h1></header><p>在第五章中已经详细讲解了函数的创建方式和直接的调用，一个代码的样例如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">func a() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;in sub function 1&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">a()</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在很多时候，临时的函数不一定需要被定名，可以直接定义函数并调用。比如如下的代码：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">func() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;in sub function 2&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}()</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在Yak中进行协程创建和延迟运行的时候都需要编写一个函数调用，很多时候会创建一个简单的临时函数，并不给他定名然后调用，将会编写类似上述示例的代码，Yak对这种情况提供了更加简单的方案：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">func {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;in sub function 3&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这样的函数等同于上述的两个函数调用。</p><p>在go关键字和defer关键字后，也可以编写这样的代码：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">defer func {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;in defer&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">go func {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;in go&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;sleep 1&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">sleep(1)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这样的程序似的程序编写的更加简洁，他的运行和定义函数进行调用是等效的，运行结果如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">sleep 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">in go</span></span><span class="token-line" style="color:#393A34"><span class="token plain">in defer</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><header><h1>6.4 并发控制：sync</h1></header><p>在本章中已经提到协程的创建和使用，创建一个协程的开销很低，远远低于线程，是进行异步编程的重要基础。但在Yak的异步编程中，需要考虑两个问题：</p><ul><li>异步编程处理数据的时候，需要有手段可以等待所有期望的协程结束，然后收集资源。</li><li>创建协程是有开销的，无限制地去创建协程只会让资源被白白浪费掉。需要有手段可以控制某个功能创建协程的数量上限。</li></ul><p>对于协程的并发控制，在Yak提供了许多并发控制的支持。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="641-等待异步执行-waitgroup"></a>6.4.1 等待异步执行: <code>WaitGroup</code><a class="hash-link" href="#641-等待异步执行-waitgroup" title="Direct link to heading">#</a></h2><p>下面请看这样一段代码样例：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">for i in 16 {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    num = i </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    go func{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        sleep(1)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(num)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;for statement done!&quot;)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这段代码样例中，首先运行循环，在循环内创建协程打印数据，并且每个协程都会调用sleep函数等待1秒，最后打印循环结束的字符串。</p><p>但是这段程序的运行结果如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">for statement done!</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>可以看到只有程序最后的输出。</p><p>出现这一情况的原因是，协程都是互相独立运行的，主程序也是一个单独的协程，程序在循环中创建了16个协程，算上主协程一共有17个协程，在循环内创建的协程都会等待1秒然后在打印数据，而主协程将会继续执行，主协程执行结束之后整个程序将会停止运行，所有的其他协程都会被销毁。</p><p>为了解决这样一个问题，Yak提供了等待协程的工具：WaitGroup，以下的代码展示了WaitGroup的使用，并通过这一工具解决了前一个代码示例中存在的问题。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">wg = sync.NewWaitGroup()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in 16 {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    num = i </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    wg.Add()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    go func{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        defer wg.Done()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(num)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">wg.Wait()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&quot;for statement done!&quot;)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>首先创建一个WaitGroup实例。</p><p>每次创建协程的时候，调用<code>wg.Add</code>方法，表示增加一个需要等待的协程，在协程内，使用defer延迟函数的形式保证调用<code>wg.Done</code>方法，表示一个需要等待的协程已经结束。</p><p>最后使用<code>wg.Wait</code>等待所有注册的协程结束。协程运行到该函数的时候将会阻塞等待，直到所有需要等待的协程都结束，才会继续向后执行。</p><p>这段代码运行结果如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Plain"><pre tabindex="0" class="prism-code language-Plain codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">7</span></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span></span><span class="token-line" style="color:#393A34"><span class="token plain">8</span></span><span class="token-line" style="color:#393A34"><span class="token plain">1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span></span><span class="token-line" style="color:#393A34"><span class="token plain">3</span></span><span class="token-line" style="color:#393A34"><span class="token plain">6</span></span><span class="token-line" style="color:#393A34"><span class="token plain">9</span></span><span class="token-line" style="color:#393A34"><span class="token plain">5</span></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span></span><span class="token-line" style="color:#393A34"><span class="token plain">4</span></span><span class="token-line" style="color:#393A34"><span class="token plain">for statement done!</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="642-控制协程数量-sizedwaitgroup"></a>6.4.2 控制协程数量： <code>SizedWaitGroup</code><a class="hash-link" href="#642-控制协程数量-sizedwaitgroup" title="Direct link to heading">#</a></h2><p><code>sync.NewSizedWaitGroup</code>是Yak并发控制中一个重要库函数，接受一个字符作为参数表示协程的容量上限，返回一个<code>SizedWaitGroup</code>对象。可以简单地认为<code>SizedWaitGroup</code>是一个计数器，计数器的值就是协程的数量。程序可以通过<code>Add</code>方法使计数器的值增加，使用<code>Done</code>方法使计数器的值减少。如果计数器的值增加到了设置的容量上限，那么<code>Add</code>函数就会堵塞到计数器的值减少为止。</p><p>以下的例子演示了<code>SideWaitGroup</code>的简单使用：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">swg = sync.NewSizedWaitGroup(1)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in 16 {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    num = i </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    swg.Add(1)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    go func{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        defer swg.Done()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(num)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">swg.Wait()</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在上述示例中，首先创建了一个SizedWaitGroup，容量上限为1。程序运行循环16次，并在每次循环中执行swg.Add(1)，然后创建一个协程打印当时的循环计数器，在协程函数内，使用defer进行延迟运行在协程退出的时候执行swg.Done()表达异步执行结束。最后在循环外使用swg.Wait()等待这个计数器归零表示所有协程都运行结束。</p><p>同时因为协程都是独立执行，将会分别打印数据，原本应该乱序输出0到15这几个字符，但是现在SizedWaitGroup对象上限为1， 也就是允许并发执行的协程最多为1， 当第一个协程调用<code>swg.Add(1)</code>的时候，<code>SizedWaitGroup</code>到达上限，下次循环运行的时候将会在<code>swg.Add(1)</code>阻塞，等待第一个协程运行结束调用<code>swg.Done()</code>后继续运行，也就导致每一个循环都需要等待前一个循环内的协程运行结束才会运行。这段程序虽然使用了协程运行，但是会表现出同步运行的特性，得到的结果将会是顺序打印0到15。</p><p>sync库还提供了很多其他函数可以帮助我们完成并发控制，详情可以查看官方文档。</p><header><h1>6.5 通道类型与并发编程：channel</h1></header><p>在并发编程中，通信和数据共享是一个核心的问题。Yak语言引入了一种特殊的数据类型 - channel，它就像是一个邮局，可以帮助不同协程之间轻松地发送和接收数据。</p><p>本书第三章3.3.3已经简单介绍了通道类型的简单使用，本章节将继续深入探讨Yak中的channel，让读者更好地理解和使用这个强大的工具。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="651-缓冲区和阻塞"></a>6.5.1 <strong>缓冲区和阻塞</strong><a class="hash-link" href="#651-缓冲区和阻塞" title="Direct link to heading">#</a></h2><p>可以将 Channel 理解为一个先入先出的管道，同时可以从一侧放入数据另一侧拿出数据，缓冲区表示在这个管道内保存的数据可以有多少。</p><p>我们使用一个程序示例讲解这个特性：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">ch = make(chan int, 2) // 创建Channel，缓存区为2</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">ch &lt;- 1 // 写入数据 此时缓存区[1]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">ch &lt;- 2 // 写入数据 此时缓存区[1, 2]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// ch &lt;- 3 // 写入数据 此时缓存区已经满 将会阻塞等待有数据取出才能写入</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&lt;- ch) // 取出数据 1 此时缓存区[2]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">println(&lt;- ch) // 取出数据 2 此时缓存区[]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// println(&lt;- ch) // 缓存区为空 将会阻塞等待数据写入</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当缓存区满时，需要等待取出数据才可以继续向 channel 写入数据，当缓存区空时需要等待写入数据才可以从 channel 取出数据。</p><p>同样，如果没有设置缓冲区，无缓存区，表示缓存区大小默认为 0，此时只有两端同时读写才不会出现阻塞等待，否则无论是读还是写都会出现等待。</p><p>另一个需要注意的点是，当缓存区空以后继续尝试读取数据，如果是未关闭的 Channel 会导致阻塞等待，关闭的 Channel 则会直接返回nil, false`，当使用for-range或for-in进行数据遍历的时候，当缓存区为空时，未关闭 Channel 一样会等待，已关闭的 Channel 则会跳出循环。在不需要再数据写入的时候，应该关闭 Channel。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="652与协程一起工作"></a>6.5.2<strong>与协程一起工作</strong><a class="hash-link" href="#652与协程一起工作" title="Direct link to heading">#</a></h2><p>单独使用 Channel 的阻塞特性可能让人奇怪，但是如果和协程一起工作，则会形成非常高效的并发通讯。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI Go"><pre tabindex="0" class="prism-code language-Go codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">ch1 = make(chan int)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">ch2 = make(chan int)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">go fn{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for i=0; i&lt;100; i++ {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ch1 &lt;- i // 在协程中生成0-100写入Channel中</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    close(ch1) // 第一阶段数据写入结束 关闭ch1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">go fn{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        i, ok := &lt;- ch1 // 获取数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if !ok {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            break // 当 close(ch1)以后 ok=false</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ch2 &lt;- i + 2 // 从ch1中获取到的数据运算继续写入ch2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    close(ch2) // 第二阶段数据写入结束 关闭ch2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">for i = range ch2 { // 通过for-range读取ch2中的数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(i)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>以上的示例中，展示了协程之间数据传输的方案。首先创建两个channel并创建两个协程，第一个协程向<code>ch1</code>中写入0到100，第二个协程从<code>ch1</code>中读取数据，运算并写入<code>ch2</code>， 最后在</p><p>数据写入通过ch &lt;- 1进行，数据写入结束以后通过<code>close(ch)</code>关闭channel。</p><p>数据读取在代码示例中使用了两种方法： </p><ul><li>循环使用v, ok := &lt;- ch并判断!ok的方案，可以读取 ch 内写入的所有数据，直到 Channel 关闭；</li><li>另一种方案使用for v = range ch或for v in ch通过循环遍历获取数据，同样是获取 Channel 内写入的所有数据，直到 Channel 关闭。</li></ul><p>该代码样例将会打印从2到101的数据，并且由于使用通道进行数据传输，数据保持先入先出的原则，即使是在不同线程数据将会按照顺序打印。</p><header><h1></h1></header></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/yaklang/docs/yak-basic/cap6-1-concurrent-and-defer.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/yak-basic/cap5-function"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 函数的创建与使用</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/yak-basic/cap6-2-error-handling"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Yak 语言中的错误处理 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#611-什么是同步执行和异步执行" class="table-of-contents__link">6.1.1 什么是同步执行和异步执行</a><ul><li><a href="#a-同步执行" class="table-of-contents__link">A. <strong>同步执行：</strong></a></li><li><a href="#b-异步执行" class="table-of-contents__link">B. <strong>异步执行：</strong></a></li><li><a href="#c-同步执行和异步执行的使用" class="table-of-contents__link">C. <strong>同步执行和异步执行的使用</strong></a></li></ul></li><li><a href="#612-异步执行的方式" class="table-of-contents__link">6.1.2 异步执行的方式</a><ul><li><a href="#a进程" class="table-of-contents__link">A.进程</a></li><li><a href="#b-线程与协程" class="table-of-contents__link">B. 线程与协程</a></li></ul></li><li><a href="#613-如何在yak中使用异步编程" class="table-of-contents__link">6.1.3 如何在Yak中使用异步编程</a></li><li><a href="#621-创建延迟函数" class="table-of-contents__link">6.2.1 创建延迟函数</a></li><li><a href="#622-多个延迟函数" class="table-of-contents__link">6.2.2 多个延迟函数</a></li><li><a href="#623-程序出错时也会运行延迟函数" class="table-of-contents__link">6.2.3 程序出错时也会运行延迟函数</a></li><li><a href="#624-小结" class="table-of-contents__link">6.2.4 小结</a></li><li><a href="#641-等待异步执行-waitgroup" class="table-of-contents__link">6.4.1 等待异步执行: <code>WaitGroup</code></a></li><li><a href="#642-控制协程数量-sizedwaitgroup" class="table-of-contents__link">6.4.2 控制协程数量： <code>SizedWaitGroup</code></a></li><li><a href="#651-缓冲区和阻塞" class="table-of-contents__link">6.5.1 <strong>缓冲区和阻塞</strong></a></li><li><a href="#652与协程一起工作" class="table-of-contents__link">6.5.2<strong>与协程一起工作</strong></a></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="div--flex footer__bottom text--center"><div class="footer-logo-copyright-navigation"><div class="margin-bottom--sm"><a class="footer-link" href="/"><img src="/img/logo.png" alt="My Site Logo" class="themedImage_TMUO themedImage--light_4Vu1 footer__logo"><img src="/img/logo.png" alt="My Site Logo" class="themedImage_TMUO themedImage--dark_uzRr footer__logo"></a></div><div class="footer__copyright copyright-style"><a class="footer-a" href="https://beian.miit.gov.cn/#/Integrated/index" target="_blank">Copyright © 2025 for Yak Project. 京ICP备17047700号-3</a></div><div class="link-body"><a class="footer__link-item" href="/docs/intro" target="_blank">官方文档</a><a class="footer__link-item" href="/team">关于我们</a></div></div><div class="footer-contact-me"><a href="https://github.com/yaklang/yakit" target="_blank" class="contact-icon-body"><span role="img" aria-label="github" class="anticon anticon-github icon-style github-icon"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></span></a><div class="contact-icon-body"><span role="img" aria-label="wechat" class="anticon anticon-wechat icon-style wechat-icon"><svg viewBox="64 64 896 896" focusable="false" data-icon="wechat" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M690.1 377.4c5.9 0 11.8.2 17.6.5-24.4-128.7-158.3-227.1-319.9-227.1C209 150.8 64 271.4 64 420.2c0 81.1 43.6 154.2 111.9 203.6a21.5 21.5 0 019.1 17.6c0 2.4-.5 4.6-1.1 6.9-5.5 20.3-14.2 52.8-14.6 54.3-.7 2.6-1.7 5.2-1.7 7.9 0 5.9 4.8 10.8 10.8 10.8 2.3 0 4.2-.9 6.2-2l70.9-40.9c5.3-3.1 11-5 17.2-5 3.2 0 6.4.5 9.5 1.4 33.1 9.5 68.8 14.8 105.7 14.8 6 0 11.9-.1 17.8-.4-7.1-21-10.9-43.1-10.9-66 0-135.8 132.2-245.8 295.3-245.8zm-194.3-86.5c23.8 0 43.2 19.3 43.2 43.1s-19.3 43.1-43.2 43.1c-23.8 0-43.2-19.3-43.2-43.1s19.4-43.1 43.2-43.1zm-215.9 86.2c-23.8 0-43.2-19.3-43.2-43.1s19.3-43.1 43.2-43.1 43.2 19.3 43.2 43.1-19.4 43.1-43.2 43.1zm586.8 415.6c56.9-41.2 93.2-102 93.2-169.7 0-124-120.8-224.5-269.9-224.5-149 0-269.9 100.5-269.9 224.5S540.9 847.5 690 847.5c30.8 0 60.6-4.4 88.1-12.3 2.6-.8 5.2-1.2 7.9-1.2 5.2 0 9.9 1.6 14.3 4.1l59.1 34c1.7 1 3.3 1.7 5.2 1.7a9 9 0 006.4-2.6 9 9 0 002.6-6.4c0-2.2-.9-4.4-1.4-6.6-.3-1.2-7.6-28.3-12.2-45.3-.5-1.9-.9-3.8-.9-5.7.1-5.9 3.1-11.2 7.6-14.5zM600.2 587.2c-19.9 0-36-16.1-36-35.9 0-19.8 16.1-35.9 36-35.9s36 16.1 36 35.9c0 19.8-16.2 35.9-36 35.9zm179.9 0c-19.9 0-36-16.1-36-35.9 0-19.8 16.1-35.9 36-35.9s36 16.1 36 35.9a36.08 36.08 0 01-36 35.9z"></path></svg></span></div></div></div></div></footer></div>
<script src="/assets/js/runtime~main.306f7db8.js"></script>
<script src="/assets/js/main.52e2f472.js"></script>
</body>
</html>