<!doctype html>
<html class="docs-version-current" lang="zh-CN" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Yak Official Website Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Yak Official Website Blog Atom Feed"><title data-react-helmet="true">反连出网检测与内网穿透技术 | Yak Official Website</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://yaklang.io/products/professional/yakit-in-practice-reverse"><meta data-react-helmet="true" name="docusaurus_locale" content="zh-CN"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-products-current"><meta data-react-helmet="true" property="og:title" content="反连出网检测与内网穿透技术 | Yak Official Website"><meta data-react-helmet="true" name="description" content="yaklang.io 反连技术三板斧"><meta data-react-helmet="true" property="og:description" content="yaklang.io 反连技术三板斧"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://yaklang.io/products/professional/yakit-in-practice-reverse"><link data-react-helmet="true" rel="alternate" href="https://yaklang.io/products/professional/yakit-in-practice-reverse" hreflang="zh-CN"><link data-react-helmet="true" rel="alternate" href="https://yaklang.io/en/products/professional/yakit-in-practice-reverse" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://yaklang.io/products/professional/yakit-in-practice-reverse" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.a2fbf992.css">
<link rel="preload" href="/assets/js/runtime~main.16ce09e7.js" as="script">
<link rel="preload" href="/assets/js/main.a310b529.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Yak</b></a><a class="navbar__item navbar__link" href="/docs/intro">编程与文档</a><a class="navbar__item navbar__link navbar__link--active" href="/products/intro">Yakit 单兵平台</a><a class="navbar__item navbar__link" href="/team/intro">社区与团队</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/docs/intro">Next</a><a href="https://github.com/yaklang" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GITHUB<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/products/intro">Yakit: 集成化单兵安全能力平台</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/products/download_and_install">下载与安装指南</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Yakit 中的基础安全工具</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Yakit 技术论述</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/products/professional/yak-script-system">技术总览：&quot;地表最强&quot; 的插件系统</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/products/professional/yakit-in-practice">MITM 被动扫描核心原理</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/products/professional/yakit-in-practice-reverse">反连出网检测与内网穿透技术</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Yakit 插件体系最佳实践</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Yakit 编程最佳实践</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">研发技术漫谈: 技术解析</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">__已过时的文档</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>反连出网检测与内网穿透技术</h1></header><div class="tableOfContentsInline_3fWc"><ul class="table-of-contents"><li><a href="#yaklangio-反连技术三板斧">yaklang.io 反连技术三板斧</a></li><li><a href="#反连服务是什么？为什么要做这种服务？">反连服务是什么？为什么要做这种服务？</a><ul><li><a href="#dns-反连检测原理">DNS 反连检测原理</a></li><li><a href="#rmi--http--tls">RMI / HTTP / TLS</a></li></ul></li><li><a href="#多协议复用端口：facade-技术">多协议复用端口：<code>Facade 技术</code></a><ul><li><a href="#协议复用除了方便，还有别的好处吗？">协议复用除了方便，还有别的好处吗？</a></li></ul></li><li><a href="#内网穿透：对标实现-ngrok-穿透">内网穿透：对标实现 ngrok 穿透</a><ul><li><a href="#yak-引擎的穿透服务">yak 引擎的穿透服务</a></li></ul></li><li><a href="#融合：yakit-插件与反连技术的完美融合">融合：Yakit 插件与反连技术的完美融合</a></li></ul></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="yaklangio-反连技术三板斧"></a>yaklang.io 反连技术三板斧<a class="hash-link" href="#yaklangio-反连技术三板斧" title="Direct link to heading">#</a></h2><ol><li>反连服务</li><li>多协议复用端口</li><li>内网穿透</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="反连服务是什么？为什么要做这种服务？"></a>反连服务是什么？为什么要做这种服务？<a class="hash-link" href="#反连服务是什么？为什么要做这种服务？" title="Direct link to heading">#</a></h2><p>很多时候，我们在进行漏洞检测时无法通过应用返回的信息来确定一个漏洞是否存在。但是如果命令/特殊操作确实执行了，那我们如何证明这个命令或者特殊操作执行了呢？</p><p>我们习惯性把这种漏洞检测技术称为：无回显的漏洞检测技术。</p><p>一般来说，无回显漏洞检测技术可以分为两种：</p><ol><li><code>sleep / benchmark</code> 耗时操作检测。</li><li><code>dnslog / http-reverse / tcp / tls / rmi</code> 等服务外连检测。</li></ol><blockquote><p>严格来说，我并不觉得 <code>sleep / benchmark</code> 不算回显，耗时操作本来也算是可直接观测到的指标。除此之外，<code>sleep / benchmark</code> 将会引起服务器端各种各样的小问题：</p><ol><li>如果服务器是单线程，sleep 将会造成阻塞，</li><li>如果服务器 CPU 不太行，benchmark 将会消耗资源</li><li>如果发生在数据库中，很多生产环境中的数据库会针对 SQL 语句执行做各种限制，例如:<ol><li>认为超时的 SQL 语句为 badsql，直接切断当前查询进程</li><li>SQL 连接池恶意占用会造成其他查询失败，甚至整体 down 机</li></ol></li><li>sleep 如果执行在了 <code>for / while</code> 分支中，将会造成 sleep 的时间远大于预期值，或者直接为 0。</li></ol></blockquote><p>相比之下，服务外连检测是一个更加 &quot;稳妥&quot; 的办法。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="dns-反连检测原理"></a>DNS 反连检测原理<a class="hash-link" href="#dns-反连检测原理" title="Direct link to heading">#</a></h3><p>举个例子，服务外连时，我们执行 <code>curl abc.example.com</code> 命令：</p><ol><li>这个时候，<code>abc.example.com</code> 将会被解析，会查询 <code>abc.example.com</code> 的 NS 记录和 A 记录</li><li>如果 NS 记录存在(ns1.example.com)，会向 <code>ns1.example.com</code> 查询 <code>abc.example.com</code> 的 A 记录。</li><li>如果 NS 不存在，则直接向公共服务器启用 <code>A</code> 记录查询。</li></ol><p>上述描述的过程中，如果我们可以控制 <code>ns1.example.com</code> 的话，任何用户查询的过程将会被记录下来。</p><p>当然，我们可以人为设置一个子域名，任何查询到这个子域名的被集合展示，这就是 <code>dnslog.cn</code> 的核心原理。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="rmi--http--tls"></a>RMI / HTTP / TLS<a class="hash-link" href="#rmi--http--tls" title="Direct link to heading">#</a></h3><p>当然，在上面的例子中，我们 <code>curl abc.example.com</code> 如果可以找到对应的 IP，将会对 IP 发起一个 HTTP 请求。</p><p>这个请求的原始数据包和任何内容都可以被我们控制的反连服务器记录下来。</p><ol><li>如果我们实现了 HTTP 协议，将会记录下 HTTP 相关的详细信息</li><li>如果我们实现了 RMI / LDAP / TLS 等，就可以记录下反连时携带的信息</li></ol><p>这些信息对判断漏洞是否存在，或者收集一些敏感信息，例如 <code>AWS_SECRET_KEY / ACCESS_KEY / SECRET_KEY</code> 等很有用。</p><p><img alt="img.png" src="/assets/images/yakit-reverse-poc-600da8f34596a587af6e742bcec3451d.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="多协议复用端口：facade-技术"></a>多协议复用端口：<code>Facade 技术</code><a class="hash-link" href="#多协议复用端口：facade-技术" title="Direct link to heading">#</a></h2><p>大家在上图可能注意到了一个有趣的现象，RMI 也好 HTTP/HTTPS 也好，我们都监听在了同一个端口上。</p><p>有同学问，这样真的不会有问题吗？</p><p>这个技术并不是什么高深的技术，端口复用其实是一个很简单的操作，不同协议的协议头是不一样的：</p><p>例如：</p><ol><li>TLS 协议要先进行 TLS 握手（handshake） 操作。在 TLS 握手时，我们将会识别到这是一个 TLS 握手操作，客户端把服务器当作一个 TLS 服务来判断，那么服务端将会自动返回 TLS 应该收到的东西。</li><li>RMI 的协议头为 JRMI，当我们收到客户端发来这几个字节时，我们就应该回复 RMI 应该识别的内容</li><li>当然 HTTP 更简单了，对吧？</li></ol><p>当然我们集合了常见的这几种协议，同时在一个端口上开启，早一段时间大家管这个技术叫 <code>拟态</code>其实也可以说是 <code>yaklang.io</code> 实现了 <code>拟态</code> 反连服务器。</p><p>我们给这个服务器起名叫 <code>Facade</code></p><p><img src="/assets/images/facade-name-source-1580eb36271a4f9e1bf45c9880997049.png"></p><div class="admonition admonition-danger alert alert--danger"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"></path></svg></span>ous</h5></div><div class="admonition-content"><p>如果两个协议的头完全一样，将会造成 Facade 服务器混淆协议。</p><p>当然这种情况其实比较稀有，如果有，也可以通过设置 Facade 识别协议缓存大小来处理，大家可以不必担心协议错误的问题。</p></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="协议复用除了方便，还有别的好处吗？"></a>协议复用除了方便，还有别的好处吗？<a class="hash-link" href="#协议复用除了方便，还有别的好处吗？" title="Direct link to heading">#</a></h3><p>在实战过程中，很多用户发现，虽然我们有些协议无法识别，但是 TCP 连接始终可以识别到，这样做是为了 &quot;兜底&quot;。</p><p>遇到了见不到的协议，但是反连确实连接回来了，虽然只是 TCP，但是用户至少知道目标存在一个反连问题，不是吗？</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="内网穿透：对标实现-ngrok-穿透"></a>内网穿透：对标实现 ngrok 穿透<a class="hash-link" href="#内网穿透：对标实现-ngrok-穿透" title="Direct link to heading">#</a></h2><p>很多时候，我们在进行扫描的时候，并不一定及时能搭配起一个公网服务器开启反连服务器。</p><p>就算公网服务器开启了反连服务，我们的漏洞 Payload 打出去并不一定及时能知道自己的服务器接收到了对应反连。</p><p>那么如何解决这个问题呢？当然，对于 <code>yaklang.io</code> 项目来说，最简单的就是在公网部署一个 yak 引擎。除此之外，还有别的解决办法吗？</p><blockquote><p>熟悉 ngrok 的同学就会说，我们可以部署一个 ngrok 让本地的服务器在远端上线。</p><p>很多同学在使用 CS 上线节点的时候都这么操作。</p></blockquote><p>于是，我们在 yak 中实现了一套机制，叫 <code>cybertunnel</code>, 使用 grpc 构建了一套端口穿透的技术，我们可以实现映射一个本地 <code>tcp / udp</code> 协议端口到远端。</p><p>甚至于说，我们都可以映射一个本地 dnslog 服务器到远端（远端需要域名提供商配置解析记录）</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="yak-引擎的穿透服务"></a>yak 引擎的穿透服务<a class="hash-link" href="#yak-引擎的穿透服务" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="服务器配置"></a>服务器配置<a class="hash-link" href="#服务器配置" title="Direct link to heading">#</a></h4><p>当然，穿透服务是需要一个远端服务器打配合的</p><p>服务器上安装了 yak 核心引擎的话，使用 <code>yak bridge</code> 即可解决这个问题</p><p><code>yak bridge --secret [your-password]</code></p><p>如果只有 docker 环境，可以使用 <code>https://github.com/yaklang/yak-bridge-docker/</code> 中的解决方案</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">docker run -d --rm --net=host v1ll4n/yak-bridge yak bridge --secret [your-awesome-password-for-u-bridge]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>一条命令即可启动一个 yak bridge 服务器</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="yak-内网穿透客户端"></a>yak 内网穿透客户端<a class="hash-link" href="#yak-内网穿透客户端" title="Direct link to heading">#</a></h4><p>yak 用于穿透本地端口到 yak bridge 的时候，其实非常简单，我们执行 <code>yak tunnel -h</code> 即可看到如下帮助信息</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">➜  yak-engine yak tunnel -h</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">NAME:</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   yak tunnel -</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">USAGE:</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   yak tunnel [command options] [arguments...]</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">OPTIONS:</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   --server value                  (default: &quot;cybertunnel.run:64333&quot;)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   --local-port value              (default: 53)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   --remote-port value             (default: 53)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   --secret value</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   --network value, --proto value  (default: &quot;tcp&quot;)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>其实配置非常简单</p><ol><li><code>--server</code> 内容是我们启动的 yak bridge 的公网地址，<code>[host/ip]:[port]</code> 即可</li><li><code>--local-port</code> 是我们想要穿透的本地端口</li><li><code>--remote-port</code> 是我们想要穿透到 <code>yak bridge</code> 的远端端口</li><li><code>--secret</code> 是我们启动 yak bridge 时设置的密码</li><li><code>--network</code> 是说我们想要映射的本地端口的协议，同时支持 udp 和 tcp，因此我们可以把本地 dnslog 映射出去。</li></ol><p>我们可以使用 <code>yak tunnel</code> 映射本地任何端口出去，包括 <code>yak grpc</code>，因此我们在内网进行渗透的时候，只要运行一个 yak grpc，再通过 yak tunnel 穿透出去，就可以使用 yakit 连接了！</p><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="yakit-的反连支持"></a>yakit 的反连支持<a class="hash-link" href="#yakit-的反连支持" title="Direct link to heading">#</a></h4><p>当然，除了 yak 支持的任意端口的映射之外，我们也可以支持 yakit 把反连服务器映射到远端。</p><p>对于 yakit 来说，减轻用户的操作负担其实是最核心的诉求。</p><p><img alt="img.png" src="/assets/images/yakit-config-yak-bridge-945a6b66a1079f073f5cda5de4ce9659.png"></p><p>在我们配置完成成功连接之后，所有内容将会保存到 yakit 的本地 <code>~/yakit-projects/base/yakit-local.json</code> 文件夹中。</p><p>在之后每次启动 yakit 的时候，都会自动链接 yak bridge。无需手动再配置。。</p><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>yak bridge 只有端口映射与获取当前公网 IP 两个功能，并无其他功能，所以版本并不需要太高，只要支持 <code>yak bridge</code> 子命令均可运行。</p></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="融合：yakit-插件与反连技术的完美融合"></a>融合：Yakit 插件与反连技术的完美融合<a class="hash-link" href="#融合：yakit-插件与反连技术的完美融合" title="Direct link to heading">#</a></h2><p>当我们在 yakit 任意可执行插件的地方执行</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly go"><pre tabindex="0" class="prism-code language-go codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">url </span><span class="token operator" style="color:rgb(137, 221, 255)">:=</span><span class="token plain"> risk</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token function" style="color:rgb(130, 170, 255)">NewPublicReverseHTTPUrl</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">risk</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token function" style="color:rgb(130, 170, 255)">title</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token string" style="color:rgb(195, 232, 141)">&quot;反连服务器测试&quot;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> risk</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token keyword" style="font-style:italic">type</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token string" style="color:rgb(195, 232, 141)">&quot;测试反连&quot;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token function" style="color:rgb(130, 170, 255)">println</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">url</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">rsp</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> err </span><span class="token operator" style="color:rgb(137, 221, 255)">:=</span><span class="token plain"> http</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token function" style="color:rgb(130, 170, 255)">Get</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">url</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token function" style="color:rgb(130, 170, 255)">die</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">err</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">http</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token function" style="color:rgb(130, 170, 255)">show</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">rsp</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>我们发现我们得到了如下结果</p><p><img src="/assets/images/yakit-reverse-table-for-yak-api-0b859bfc10a75dff49defd716fcda9c1.png"></p><p>代码其实非常简单，我们在任何需要检测漏洞的时候，如果需要获取反连 URL，特别是公网可以访问的 URL。</p><p>我们使用 <code>risk.NewPublicReverseHTTPUrl / risk.NewPublicReverseRMIUrl / ...</code> 等可以获取到一个可用的带 Token 的反连 URL。</p><p>把它作为 Payload 传入漏洞检测中，即可实现反连检测漏洞。</p><p>所有具体的 API 在这里可以找到</p><p><a href="/docs/api/risk">yaklang risk 反连检测套件</a></p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/products/professional/yakit-in-practice"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« MITM 被动扫描核心原理</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/products/plugins/plugin_type"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">插件概述：定义与基础类型 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#yaklangio-反连技术三板斧" class="table-of-contents__link">yaklang.io 反连技术三板斧</a></li><li><a href="#反连服务是什么？为什么要做这种服务？" class="table-of-contents__link">反连服务是什么？为什么要做这种服务？</a><ul><li><a href="#dns-反连检测原理" class="table-of-contents__link">DNS 反连检测原理</a></li><li><a href="#rmi--http--tls" class="table-of-contents__link">RMI / HTTP / TLS</a></li></ul></li><li><a href="#多协议复用端口：facade-技术" class="table-of-contents__link">多协议复用端口：<code>Facade 技术</code></a><ul><li><a href="#协议复用除了方便，还有别的好处吗？" class="table-of-contents__link">协议复用除了方便，还有别的好处吗？</a></li></ul></li><li><a href="#内网穿透：对标实现-ngrok-穿透" class="table-of-contents__link">内网穿透：对标实现 ngrok 穿透</a><ul><li><a href="#yak-引擎的穿透服务" class="table-of-contents__link">yak 引擎的穿透服务</a></li></ul></li><li><a href="#融合：yakit-插件与反连技术的完美融合" class="table-of-contents__link">融合：Yakit 插件与反连技术的完美融合</a></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">教程与文档</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/team/intro">研发团队</a></li><li class="footer__item"><a class="footer__link-item" href="/team/contact">联系我们</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/yaklang" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 for Yak Project. Own by v1ll4n. Powered by Docusaurus</div></div></div></footer></div>
<script src="/assets/js/runtime~main.16ce09e7.js"></script>
<script src="/assets/js/main.a310b529.js"></script>
</body>
</html>